package main;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Set;

import adjlistgraph.Graph;
import andyfyp.DnDImage;
import andyfyp.ThumbnailTable;
import extendedindex.ExFreqIndex;
import extendedindex.ExIndex;
import frequentindex.Vertex;
import graph.JGraphtClosureGraph;
import graph.JGraphtGraph;
import graph.VF2;
import graph.VF2_Match;
import graph.closureEdge;
import graph.closureVertex;
import result.DotGenerator;
import graph.DBStat;
import graph.DBStatComparator;
import thread.CollapsePatternThread;
import thread.CollapsePatternThreadCompleteListener;
import thread.ComputeScoreThread;
import thread.ComputeScoreThreadCompleteListener;
import thread.ComputeScoreThreadCompleteListenerUpdated;
import thread.ComputeScoreThreadUpdated;
import thread.GenerateClosureThread;
import thread.GenerateClosureThreadCompleteListener;
import thread.GeneratePatternThread;
import thread.GeneratePatternThreadCompleteListener;
import thread.GeneratePatternThreadCompleteListenerUpdated;
import thread.GeneratePatternThreadUpdated;

public class MIDASMain {
	private String pubchem = "pubchem";
	private String emolecule = "emolecul";
	private String AIDS = "AIDS";
	// 1. Generated by readClusterFile()
	private ArrayList<Integer> fullyContainedGraphID = new ArrayList<Integer>();// all graphs in clusters
	private ArrayList<Integer> fullyContainedGraphID2 = new ArrayList<Integer>();// all graphs in clusters
	// 2. Generated by PM_generateClusterClosure()
	private ArrayList<JGraphtClosureGraph> closureGraphList = new ArrayList<JGraphtClosureGraph>();
	private ArrayList<JGraphtClosureGraph> closureGraphList2 = new ArrayList<JGraphtClosureGraph>();
	private ArrayList<Integer> closureGraphIndexList = new ArrayList<Integer>();
	private ArrayList<Integer> closureGraphIndexList2 = new ArrayList<Integer>();
	private int maxClosureSize = 0;
	private int maxClosureSize2 = 0;
	private ArrayList<Float> c_wt = new ArrayList<Float>();
	private ArrayList<Float> c_wt2 = new ArrayList<Float>();
	private ArrayList<String> DBEdgeLabel = new ArrayList<String>();
	private ArrayList<String> DBEdgeLabel2 = new ArrayList<String>();
	private ArrayList<Integer> DBEdgeLabelFreq = new ArrayList<Integer>();
	private ArrayList<Integer> DBEdgeLabelFreq2 = new ArrayList<Integer>();
	private ArrayList<Float> DBEdge_wt = new ArrayList<Float>();
	private ArrayList<Float> DBEdge_wt2 = new ArrayList<Float>();
	private ArrayList<String> DBVertexLabel = new ArrayList<String>();
	private ArrayList<String> DBVertexLabel2 = new ArrayList<String>();
	private ArrayList<Integer> DBVertexLabelValency = new ArrayList<Integer>();
	private ArrayList<Integer> DBVertexLabelValency2 = new ArrayList<Integer>();
	private ArrayList<ArrayList<closureEdge>> distinctCandidatePatterns = new ArrayList<ArrayList<closureEdge>>();
	private ArrayList<ArrayList<closureEdge>> distinctCandidatePatterns2 = new ArrayList<ArrayList<closureEdge>>();
	private ArrayList<ArrayList<Integer>> distinctCandidatePatterns_closureIndex = new ArrayList<ArrayList<Integer>>();
	private ArrayList<ArrayList<Integer>> distinctCandidatePatterns_closureIndex2 = new ArrayList<ArrayList<Integer>>();
	// --------------------------------------------------------------------------
	// private VF2 VF2_operator = new VF2();
	private ArrayList<ArrayList<closureEdge>> candidatePatterns = new ArrayList<ArrayList<closureEdge>>();
	private ArrayList<ArrayList<closureEdge>> candidatePatterns2 = new ArrayList<ArrayList<closureEdge>>();
	private ArrayList<Integer> candidatePatterns_closureIndex = new ArrayList<Integer>();
	private ArrayList<Integer> candidatePatterns_closureIndex2 = new ArrayList<Integer>();
	// --------------------------------------------------------------------------
	// private int CSI_A;
	private ArrayList<Double> distinctCandidatePatterns_score = new ArrayList<Double>();
	private ArrayList<Double> distinctCandidatePatterns_score2 = new ArrayList<Double>();
	private DotGenerator dotGenerator = new DotGenerator();
	private DotGenerator dotGenerator2 = new DotGenerator();
	// private String DBName;
	private int minCannedPatternSize = 3;
	private int maxCannedPatternSize = 12;
	
	private int minCannedPatternSize2 = 3;
	private int maxCannedPatternSize2 = 12;
	//AIDS dataset
	  private static String[] vertexLable1= {
	  	"C", "O", "Cu", "N", "S", "P", "Cl", "Zn", "B", "Br", "Co", "Mn", "As", "Al", "Ni", "Se",
	  	"Si", "V", "Sn", "I", "F", "Li", "Sb", "Fe", "Pd", "Hg", "Bi", "Na", "Ca", "Ti", "Ho", "Ge",
	  	"Pt", "Ru", "Rh", "Cr", "Ga", "K", "Ag", "Au", "Tb", "Ir", "Te", "Mg", "Pb", "W", "Cs", "Mo",
	  	"Re", "Cd", "Os", "Pr", "Nd", "Sm", "Gd", "Yb", "Er", "U", "Tl", "Ac" };
	 
	  /*
	  //emolecule dataset, 74->130
	
	   private static String[] vertexLable1= {
	  "Cs", "Cu", "Yb", "Cl", "Pt", "Pr", "Co", "Cr", "Li", "Cd", "Ce", "Hg", "Hf", "La", "Lu",
	  "Pd", "Tl", "Tm", "Ho", "Pb", "*", "Ti", "Te", "Dy", "Ta", "Os", "Mg", "Tb", "Au", "Se",
	  "F", "Sc", "Fe", "In", "Si", "B", "C", "As", "Sn", "N", "Ba", "O", "Eu", "H", "Sr", "I", "Mo",
	  "Mn", "K", "Ir", "Er", "Ru", "Ag", "W", "V", "Ni", "P", "S", "Nb",
	  "Y", "Na", "Sb", "Al", "Ge", "Rb", "Re", "Gd", "Ga", "Br", "Rh", "Ca", "Bi", "Zn", "Zr",
	  "R#", "R","X","R1","A","U",	"Ar",	"Kr",	"Xe",	"e", ".",	"Tc",	 "Mu", "Mu-", "He",	"Ps",	"At",
	  "Po",	"Be",	"Ne","Rn",	"Fr",	"Ra",	"Ac",	"Rf",	"Db", "Sg","Bh",	"Hs",		"Mt",
	  "Ds",	"Rg",	"Nd","Pm",		"Sm",	"Th",	"Pa",	"Np","Pu",	"Am",	"Cm",	"Bk",
	  "Cf","Es",	"Fm",	"Md", "No",	"Lr","0",	"Uub", "R2",	"R3",	"R4",	"D", "R5",	"ACP"
	  };
      */
	   
	 
	  //modified: added a new label  "Lr"
	  //pubchem dataset
	 //  private  static String[] vertexLable1=  {
	//  "H", "C", "O", "N", "Cl", "S", "F", "P", "Br", "I", "Na", "Si",
	//  "As", "Hg", "Ca", "K", "B", "Sn", "Se", "Al", "Fe", "Mg", "Zn", "Pb", "Co", "Cu",
	//  "Cr", "Mn", "Sb", "Cd", "Ni", "Be", "Ag", "Li", "Tl", "Sr", "Bi", "Ce", "Ba", "U", "Ge",
	//  "Pt", "Te", "V", "Zr", "Cs", "Au", "Mo", "W", "La", "Ti", "Rh", "Lu", "Pd", "In", "Eu", "Ga",
	 // "Pr", "Ho", "Th", "Ta", "Tc", "Tb", "Ir", "Nd", "Nb", "Rb", "Kr", "Yb", "Cm", "Pu", "Cf", "Hf",
	 // "He", "Pa", "Tm", "Pm", "Po", "Xe", "Dy", "Os", "Md", "Sc", "Ar", "At", "Sm", "Er", "Ru",
	//  "Es", "Ac", "Am", "Ne", "Y", "Re", "Gd", "No", "Rn", "Np", "Fm", "Bk", "Lr"
	//  };
	// private int numCannedPatterns;
	private int GUISize = 30;
	private int GUISize2 = 30;
	private String dbName = AIDS;
	private String DataBaseName = "AIDS40k";
	private String InitialPatternName = "patterns/thumbnailsAIDS25KCATAPULT/GUIPatterns.txt";
	private static double D_threshold = 0.2417d; ///// alpha = 95%, D_alpha/2, 30 = 0.2417. D-test Table (or KS-test Table)
	// private String InitialClusterName = "Clusters/initialclusterAIDS25K.txt";
	private String InitialClusterName = "Clusters/initialclusterAIDS25KCATAPULT.txt";
	private String UpdateClusterName = "Clusters/updatecluster25K+15K.txt";
	private static String FCT_Name = "index/AIDS25K_initialfrequentsubtree_support0.1";
	private static String FCT_Name_Updated = "index/AIDS40K_initialfrequentsubtree_support0.1";
	private static String TG_Name = "index/AIDS25K_fctindexTG_support0.1";
	private static String FEG_Name = "index/AIDS25K_feindexEG_support0.1";
	private static String IFEG_Name = "index/AIDS25K_ifeindexEG_support0.1";
	private static String TP_Name = "index/AIDS25K_fctindexTP_support0.1";
	private static String FEP_Name = "index/AIDS25K_feindexEP_support0.1";
	private static String IFEP_Name = "index/AIDS25K_ifeindexEP_support0.1";
	private static String TG_Name_Updated = "index/AIDS40K_fctindexTG_support0.1";
	private static String FEG_Name_Updated = "index/AIDS40K_feindexEG_support0.1";
	private static String IFEG_Name_Updated = "index/AIDS40K_ifeindexEG_support0.1";
	private static String TP_Name_Updated = "index/AIDS40K_fctindexTP_support0.1";
	private static String FEP_Name_Updated = "index/AIDS40K_feindexEP_support0.1";
	private static String IFEP_Name_Updated = "index/AIDS40K_ifeindexEP_support0.1";
	private float Kappa = 0.1f;
	private float Lamda_sp = 0.1f;
	private float Lamda_div = 0f;
	private float Lamda_cog = 0f;
	private float Lamda_lcov = 0f;
	private VF2 VF2_operator = new VF2();
	private KSTest test = new KSTest(0, 0);
	private int SampledDataSizeForTesting;
	private Trie trietree;
	private static ArrayList<ArrayList<closureEdge>> GUIPatterns = new ArrayList<ArrayList<closureEdge>>();
	private static ArrayList<Double> GUIPatternsScore = new ArrayList<Double>();
	private static ArrayList<ArrayList<closureEdge>> GUIPatterns2 = new ArrayList<ArrayList<closureEdge>>();
	private static ArrayList<Double> GUIPatternsScore2 = new ArrayList<Double>();
	
	public static void main(String[] args) throws IOException {
		RunMidas();  
	}
	
	public static void RunMidas() throws IOException {
		// TODO Auto-generated method stub
		MIDASMain gen = new MIDASMain();
		gen.setDataBaseName("AIDS40k");
		gen.setDbName("AIDS");
		gen.setInitialPatternName("patterns/Revision_25kiCatapult/GUIPatterns.txt");
		//gen.setUpdateClusterName("Clusters/updatecluster25K+5Kepislon0.1.txt");
		gen.setUpdateClusterName("Clusters/updatecluster25K+15K.txt");
		boolean USEGED = true;
		boolean USEINDEX = true;
		boolean USEEDGEPRUNE = true; 
		Trie TrieIndex  =  ConstructIndices(gen);
		TrieIndex.setUSEIGED(USEGED);
		TrieIndex.setUSEINDEX(USEINDEX);
		TrieIndex.setUSEEDGEPRUNE(USEEDGEPRUNE);
		//// 1. read existing data graphs
		ArrayList<Integer> graphIdList = new ArrayList<Integer>();
		graphIdList = gen.readGraphIDinClustersFromFile(gen.getUpdateClusterName());
		ArrayList<JGraphtClosureGraph> Updated_datagraphs = gen.readJGraphtClosureGraphFromFile(gen.getDataBaseName(), graphIdList, false);
		gen.setSampledDataSizeForTesting(Updated_datagraphs.size());
       // System.out.println("Updated_datagraphs.size(): "+Updated_datagraphs.size());
     
		//// 2. read existing patterns
		ArrayList<Integer> patternIdList = new ArrayList<Integer>();
		for (int i = 0; i < gen.getGUISize(); i++)
			patternIdList.add(i);
		ArrayList<JGraphtClosureGraph> existingpatterns = gen.readJGraphtClosureGraphFromFile(gen.getInitialPatternName(), patternIdList, false);
		PatternResult existingpr = gen.calculateUpdatedPatternScore(existingpatterns,  patternIdList, Updated_datagraphs,TrieIndex);
		TrieIndex.update(existingpr, gen.getKappa(), graphIdList);
		gen.trietree  = TrieIndex;
		Long startTime = System.currentTimeMillis();
		
		///// 3. generate updated patterns
        gen.UpdatedgeneratePatterns2(gen.trietree);
		ArrayList<JGraphtClosureGraph> newpatterns = new ArrayList<JGraphtClosureGraph>();
		for (int i = 0; i < GUIPatterns2.size(); i++) {
			JGraphtClosureGraph p = new JGraphtClosureGraph(GUIPatterns2.get(i));
			if (gen.isDuplitedGraph(p, existingpatterns))
				continue;
			newpatterns.add(p);
		}
		ArrayList<Integer> newpatternIdList = new ArrayList<Integer>();
		for (int i = 0; i < newpatterns.size(); i++)
			newpatternIdList.add(i);
		//PatternResult newpr = gen.calculatePatternScore(newpatterns, FCT_Name_Updated, TG_Name_Updated, FEG_Name_Updated, IFEG_Name_Updated, TP_Name_Updated, FEP_Name_Updated, IFEP_Name_Updated,
		//		newpatternIdList, Updated_datagraphs);
		PatternResult newpr = gen.calculateUpdatedPatternScore(newpatterns, newpatternIdList, Updated_datagraphs,TrieIndex);
		Long endTime1 = System.currentTimeMillis();	
		///// 4. pattern swapping
		ArrayList<JGraphtClosureGraph> UpdatePatterns = gen.MultiScanSwap(existingpatterns, existingpr, newpatterns,
				newpr);
		ArrayList<ArrayList<closureEdge>> UpPatterns = new ArrayList<ArrayList<closureEdge>>();
		for (int i = 0; i < UpdatePatterns.size(); i++)
			UpPatterns.add(gen.transJGraphtClosureGraphToclosureEdges(UpdatePatterns.get(i)));
		// process database-END
		String pathToSaveImage = gen.PM_resetThumbnailFolder();
		gen.PM_generateThumbnails(pathToSaveImage, UpPatterns, gen.getDbName());
		gen.PM_loadThumbnails(pathToSaveImage);

		gen.PM_savePatternsToFile(pathToSaveImage, UpPatterns);

		Long endTime2 = System.currentTimeMillis();
		
		//System.out.println("Time 1: " + (endTime1 - startTime) + ", Time 2:" +  (endTime2 - endTime1) );
		System.out.println("The generated patterns are in \\patterns\\thumbnails" );
	}
	
	

	public static int findElementFromArray(String[] array,String value){
		for(int i = 0;i<array.length;i++){
			if(value.compareTo(array[i])==0){
				return i;
			}
		}
		return -1;
	}
	
	public static Trie ConstructIndices(MIDASMain gen) throws IOException {
        gen.setFCT_Name("index/AIDS25K_initialfrequentsubtree_support0.1");
		gen.setFCT_Name_Updated("index/AIDS40K_initialfrequentsubtree_support0.1");
		
		gen.setTG_Name("index/AIDS25K_fctindexTG_support0.1");
		gen.setTG_Name_Updated("index/AIDS40K_fctindexTG_support0.1");
		
		gen.setTP_Name("index/AIDS25K_fctindexTP_support0.1");
		gen.setTP_Name_Updated("index/AIDS40K_fctindexTP_support0.1");
		
		gen.setFEG_Name("index/AIDS25K_feindexEG_support0.1");
		gen.setFEG_Name_Updated("index/AIDS40K_feindexEG_support0.1");
		
		gen.setFEP_Name("index/AIDS25K_feindexEP_support0.1");
		gen.setFEP_Name_Updated("index/AIDS40K_feindexEP_support0.1");
		
		gen.setIFEG_Name("index/AIDS25K_ifeindexEG_support0.1");
		gen.setIFEG_Name_Updated("index/AIDS40K_ifeindexEG_support0.1");
		
		gen.setIFEP_Name("index/AIDS25K_ifeindexEP_support0.1");
		gen.setIFEP_Name_Updated("index/AIDS40K_ifeindexEP_support0.1");
		
		
		String UsedIDFileName  =  "index/AIDS40KUsedID.txt";
		
        ////// Construct Trie Index
		Trie TrieIndex = new Trie();
        /// 0.1  read fct and construct fct index 
		String fctname   =  gen.getFCT_Name_Updated(); 
		ArrayList <JGraphtClosureGraph> fct =  readFCT( fctname);
		//System.out.println("FCT size: " + fct.size());
		
	    ArrayList<Integer> selectedfctid = new  ArrayList<Integer> ();
		if(true) {
			int count =0 ;
			String strLine = null;
			fctname = UsedIDFileName;
			File fin = new File(fctname);
		    BufferedReader br = null; int numberoffct = 0;
			br = new BufferedReader(new InputStreamReader(new DataInputStream(new FileInputStream(fin))));
			while ((strLine = br.readLine()) != null ) {
				count++;
				if(count < fct.size()) {
					int id = Integer.parseInt(strLine.trim());
					selectedfctid.add(id);
				}
				else break;
			}
			br.close();
		}
		TrieIndex.setFct(fct);

		//System.out.println("selectedfctid: "+selectedfctid.toString());
		ArrayList<ArrayList<Integer>>   containedGraphIDs = new ArrayList<ArrayList<Integer>>  ();
		ArrayList<ArrayList<Integer>>  containedTimesofGraph = new ArrayList<ArrayList<Integer>>  ();
	    fctname  = gen.getTG_Name();
	    String strLine = null;
		File fin = new File(fctname);
	    BufferedReader br = null; 
		br = new BufferedReader(new InputStreamReader(new DataInputStream(new FileInputStream(fin))));
		int count = -1;
		while ((strLine = br.readLine()) != null ) {
			    strLine  = strLine.trim();  if(strLine.length()==0) continue;
			    count++;
			    if(selectedfctid.indexOf(count) ==-1) {
			    	continue;
			    }
				String[] str = strLine.split("\\s+");
				ArrayList<Integer>  temp_containedGraphIDs = new ArrayList<Integer>  ();
				ArrayList<Integer>   temp_containedTimesofGraph = new ArrayList<Integer> ();
				for(int i=0;i<str.length;i++) {
					String[] temp = str[i].split(",");
					temp_containedGraphIDs.add(Integer.valueOf(temp[0]));
					temp_containedTimesofGraph.add(Integer.valueOf(temp[1]));
				}
				containedGraphIDs.add(temp_containedGraphIDs);
				containedTimesofGraph.add(temp_containedTimesofGraph);
		}
		br.close();
		TrieIndex.setContainedGraphIDs(containedGraphIDs);
		TrieIndex.setContainedTimesofGraph(containedTimesofGraph);
		
	   ///// 0.2 read edges and edge index 
	   /// FEG
	   String edgefilename = gen.getFEG_Name_Updated();
	    ArrayList <String> Edges =  new ArrayList <String> ();
	    ArrayList<ArrayList<Integer>>   containedGraphIDs_ByEdges = new ArrayList<ArrayList<Integer>>  ();
		ArrayList<ArrayList<Integer>>  containedTimesofGraph_ByEdges = new ArrayList<ArrayList<Integer>>  ();
	    String strLine2 = null;
	    File fin2 = new File(edgefilename);
	    BufferedReader br2 = null;
		br2 = new BufferedReader(new InputStreamReader(new DataInputStream(new FileInputStream(fin2))));
	    while ((strLine2 = br2.readLine()) != null ) {
				  String[] StrArray =  strLine2.split(":");
				  String label =  StrArray[0];
				  String[] templabel = label.split("\\s+");
				  int  label1 = findElementFromArray(vertexLable1,  templabel[0]) ;
				  int  label2 = findElementFromArray(vertexLable1,  templabel[1]) ;
				  //System.out.println(templabel[0]  +  "," + templabel[1]);
				 // System.out.println(label1 +  ":" + label2);
				  if(label1 < label2)  Edges.add(label1 + " " + label2);
				  else  Edges.add(label2 + " " + label1);
					  
				 // Edges.add(StrArray[0]);
				   ArrayList<Integer>  containedGraphIDs_ByEdge = new ArrayList<Integer> ();
				   ArrayList<Integer>  containedTimesofGraph_ByEdge = new ArrayList<Integer> ();
				  String[] tempstr  =  StrArray[1].split("\\s+");
				  for(int i=0;i<tempstr.length;i++) {
					  String[] str2 = tempstr[i].split(",");
					  containedGraphIDs_ByEdge.add(Integer.parseInt(str2[0]));
					  containedTimesofGraph_ByEdge.add(Integer.parseInt(str2[1]));
				  }
				  containedGraphIDs_ByEdges.add(containedGraphIDs_ByEdge);
				  containedTimesofGraph_ByEdges.add(containedTimesofGraph_ByEdge);
			}
		br2.close();
		// IFEG 
		edgefilename = gen.getIFEG_Name_Updated();
		fin2 = new File(edgefilename);
	    br2 = null;
		br2 = new BufferedReader(new InputStreamReader(new DataInputStream(new FileInputStream(fin2))));
	    while ((strLine2 = br2.readLine()) != null ) {
				  String[] StrArray =  strLine2.split(":");
				  
				  String label =  StrArray[0];
				  String[] templabel = label.split("\\s+");
				  int  label1 = findElementFromArray(vertexLable1,  templabel[0]) ;
				  int  label2 = findElementFromArray(vertexLable1,  templabel[1]) ;
				 // System.out.println(templabel[0]  +  "," + templabel[1]);
				 // System.out.println(label1 +  ":" + label2);
				  if(label1 < label2)  Edges.add(label1 + " " + label2);
				  else  Edges.add(label2 + " " + label1);
				  //Edges.add(StrArray[0]);
				   ArrayList<Integer>  containedGraphIDs_ByEdge = new ArrayList<Integer> ();
				   ArrayList<Integer>  containedTimesofGraph_ByEdge = new ArrayList<Integer> ();
				  String[] tempstr  =  StrArray[1].split("\\s+");
				  for(int i=0;i<tempstr.length;i++) {
					  String[] str2 = tempstr[i].split(",");
					  containedGraphIDs_ByEdge.add(Integer.parseInt(str2[0]));
					  containedTimesofGraph_ByEdge.add(Integer.parseInt(str2[1]));
				  }
				  containedGraphIDs_ByEdges.add(containedGraphIDs_ByEdge);
				  containedTimesofGraph_ByEdges.add(containedTimesofGraph_ByEdge);
			}
		br2.close();
		TrieIndex.setEdges(Edges);
		TrieIndex.setContainedGraphIDs_ByEdges(containedGraphIDs_ByEdges);
		TrieIndex.setContainedTimesofGraph_ByEdges(containedTimesofGraph_ByEdges);

	//	for(int i=0;i<fct.size();i++) {
	//		JGraphtClosureGraph g = 	fct.get(i);
	//		g.ConvertJGraphtClosureGraphToCanonicalString();
	//		ArrayList<String> s  =  new  ArrayList<String>();
	//		ArrayList<Integer>  str = g.getCanonicalString();
	//		for(int k=2; k< str.size()-1;k++ ) {
	//			s.add(String.valueOf(str.get(k)));
	//		}
	//		TrieIndex.insert((String[])s.toArray(), containedGraphIDs.get(i), containedTimesofGraph.get(i));
	//	}
		
		return TrieIndex;
	}

	
	public static ArrayList <JGraphtClosureGraph> readFCT(String fctname) throws IOException {
	   //System.out.println("fctname: "+ fctname);
	    ArrayList<Integer> IdList = new ArrayList<Integer> (); 
	    boolean flag;String strLine = null;
		File fin = new File(fctname);
	    BufferedReader br = null; int numberoffct = 0;
		br = new BufferedReader(new InputStreamReader(new DataInputStream(new FileInputStream(fin))));
		while ((strLine = br.readLine()) != null ) {
					if (strLine.contains("t # ")) {
						IdList.add(numberoffct);
						numberoffct++;
					}
		}
		br.close();
	  // System.out.println("number of fct : " + numberoffct);
	   ExIndex exIndex = new ExIndex(); 
	   exIndex.readGraphSetForSpecificGraphIds(fctname, IdList, flag = false);   // flag = false
	  ////  read  all graphs In   graphIdList
	  ArrayList<JGraphtGraph> jGraphTGraphSet = exIndex.getjGraphTGraphSet();
	 // System.out.println("jGraphTGraphSet size : " + jGraphTGraphSet.size()); 
	  // for(int i=0;i<jGraphTGraphSet.size();i++)  
	//	     System.out.print(jGraphTGraphSet.get(i).getNumNodes() + "," + jGraphTGraphSet.get(i).getEdgeSet().size() + ";");
	 //  System.out.println("-----");
	   ArrayList <JGraphtClosureGraph> fct = new ArrayList <JGraphtClosureGraph>();
	   for(int i =0;i<jGraphTGraphSet.size();i++) {
			   int graphId = IdList.get(i);
				JGraphtGraph thisGraph = jGraphTGraphSet.get(i);		
				JGraphtClosureGraph closureGraph = new JGraphtClosureGraph(thisGraph, graphId);
				// closureGraph.print();
				fct.add(closureGraph);
		   }
	   //System.out.println("FCT size : " + fct.size());
	   return fct;
	}
	
	public ArrayList<Integer> readGraphIDinClustersFromFile(String fileName) {
		readClusterFile(fileName);
		return fullyContainedGraphID;
	}

	/// Can read Graphs and Patterns from file
	public ArrayList<JGraphtClosureGraph> readJGraphtClosureGraphFromFile(String databasename,
			ArrayList<Integer> graphIdList, boolean flag) {
		ExIndex exIndex = new ExIndex();
		exIndex.readGraphSetForSpecificGraphIds(databasename, graphIdList, flag = false); // flag = false
		//// read all graphs In graphIdList
		ArrayList<JGraphtGraph> jGraphTGraphSet = exIndex.getjGraphTGraphSet();
		ArrayList<JGraphtClosureGraph> resultJGraphtClosureGraph = new ArrayList<JGraphtClosureGraph>();
  	    for (int i = 0; i < jGraphTGraphSet.size(); i++) {
			//int graphId = graphIdList.get(i);
			JGraphtGraph thisGraph = jGraphTGraphSet.get(i);
			//JGraphtClosureGraph closureGraph = new JGraphtClosureGraph(thisGraph, graphId);
			JGraphtClosureGraph closureGraph = new JGraphtClosureGraph(thisGraph, i);
			 //System.out.println(i);
		//	closureGraph.print();
			resultJGraphtClosureGraph.add(closureGraph);
		}
		return resultJGraphtClosureGraph;
	}

	public ArrayList<closureEdge> transJGraphtClosureGraphToclosureEdges(JGraphtClosureGraph JG) {
		// System.out.println(" JG.getG()1: " + JG.getG().edgeSet().size());
		ArrayList<closureEdge> ans = new ArrayList<closureEdge>();
		Set eSet = JG.getG().edgeSet();
		Iterator i = eSet.iterator();
		int count = 0;
		while (i.hasNext()) {
			// System.out.println("Edge " + (count++));
			// ((closureEdge) i.next()).print();
			ans.add((closureEdge) i.next());
		}
		// System.out.println(" JG.getG()2: " +ans.size());
		return ans;
	}


	public boolean isDuplitedGraph(JGraphtClosureGraph query, ArrayList<JGraphtClosureGraph> existingpatterns) {
		for (int i = 0; i < existingpatterns.size(); i++) {
			JGraphtClosureGraph datagraph = existingpatterns.get(i);
			if (query.getNumNodes() == datagraph.getNumNodes() && query.getNumEdges() == datagraph.getNumEdges()) {
				VF2_Match matchedPairs = new VF2_Match();
				matchedPairs = VF2_operator.doVF2(matchedPairs, query, datagraph, false);
				if (matchedPairs == null)
					continue;
				if (matchedPairs.getBestNumMatch() == query.getClosureVertexList().size())
					return true;
			}
		}
		return false;
	}

	public double getSubgraphCoverageOfPatternSet(ArrayList<ArrayList<Integer>> CoveredGraphIds) {
		int tempcount = 0;
		Set<Integer> hashSet = new HashSet<Integer>();
		for (int i = 0; i < CoveredGraphIds.size(); i++)
			for (int j = 0; j < CoveredGraphIds.get(i).size(); j++)
				hashSet.add(CoveredGraphIds.get(i).get(j));
		ArrayList<Integer> alreadycovered = new ArrayList<Integer>();
		System.out.print("getSubgraphCoverageOfPatternSet:");
		Iterator it = hashSet.iterator();
		while (it.hasNext()) {
			int id = (int) it.next();
			tempcount++;
		}
		System.out.println(tempcount + ",  Coverage rate is: " + tempcount * 1.0 / this.getSampledDataSizeForTesting());
		return tempcount * 1.0 / this.getSampledDataSizeForTesting();
	}
	
	private int getDistinctVertices(ArrayList<closureEdge> pattern) {
		ArrayList<closureVertex> distinctVertices = new ArrayList<closureVertex>();
		for (int i = 0; i < pattern.size(); i++) {
			closureVertex s = pattern.get(i).getSource();
			closureVertex t = pattern.get(i).getTarget();

			if (distinctVertices.contains(s) == false)
				distinctVertices.add(s);
			if (distinctVertices.contains(t) == false)
				distinctVertices.add(t);
		}

		return distinctVertices.size();
	}

    public double   getMinDiversity(ArrayList<JGraphtClosureGraph>  ExistedPattern) {
	  double  mindiv = 1000;
	  for (int i = 0; i < ExistedPattern.size(); i++) {
			ArrayList<ArrayList<closureEdge>> targetpatterns = new ArrayList<ArrayList<closureEdge>>();
			ArrayList<closureEdge> targetp = new ArrayList<closureEdge>();
			targetp = transJGraphtClosureGraphToclosureEdges(ExistedPattern.get(i));
			targetpatterns.add(targetp);
			ArrayList<ArrayList<closureEdge>> otherpatterns = new ArrayList<ArrayList<closureEdge>>();
			for (int j = 0; j < ExistedPattern.size(); j++) {
				if (j == i)
					continue;
				ArrayList<closureEdge> otherp = new ArrayList<closureEdge>();
				otherp = transJGraphtClosureGraphToclosureEdges(ExistedPattern.get(j));
				otherpatterns.add(otherp);
			}
			ArrayList<Integer> pIndex = new ArrayList<Integer>();
			pIndex.add(0);
			ComputeScore cs = new ComputeScore(pIndex, targetpatterns, otherpatterns, FCT_Name, TG_Name, FEG_Name,IFEG_Name, TP_Name, FEP_Name, IFEP_Name, new ArrayList<Integer>(), new ArrayList<JGraphtClosureGraph>());
	
			double minGED =  cs.computeGEDMunkresWithLowerBoundGED2(0, otherpatterns, targetp);
			
			if(minGED < mindiv)
				mindiv = minGED;
	  }
	  return mindiv;
}

    public double   getMinCog(ArrayList<JGraphtClosureGraph>  ExistedPattern) {
	  double mincog = 1000000;
      for (int i = 0; i < ExistedPattern.size(); i++) {
		double size = (float) (ExistedPattern.get(i).getClosureEdgeList().size());
		double numEdge = size;
		double numVertex = (float) (getDistinctVertices(ExistedPattern.get(i).getClosureEdgeList()));
		double cognitiveCost = 1f;
		double density = 2 * numEdge / (numVertex * (numVertex - 1));
		double score;
		cognitiveCost = size * density;
		if(cognitiveCost < mincog) {
			mincog = cognitiveCost;
		}
    }
    return mincog;
}

	public ArrayList<JGraphtClosureGraph> MultiScanSwap(ArrayList<JGraphtClosureGraph> existingpatterns,
			PatternResult existingpr, ArrayList<JGraphtClosureGraph> newpatterns, PatternResult newpr) {
		
		ArrayList<JGraphtClosureGraph> UpdatePatterns = new ArrayList<JGraphtClosureGraph>();
		ArrayList<ArrayList<Integer>>  UpdateGraphId_Edges = new ArrayList<ArrayList<Integer>>();
		
		ArrayList<JGraphtClosureGraph> ExistedPattern = new ArrayList<JGraphtClosureGraph>();
		ArrayList<Integer> ExistedPatternIndex = new ArrayList<Integer>();
		ArrayList<Double> Existedsubgraphcoverage = new ArrayList<Double>();
		ArrayList<Double> Existedpatternscore = new ArrayList<Double>();
		ArrayList<ArrayList<Integer>> ExistedCoveredGraphIds = new ArrayList<ArrayList<Integer>>();
		ArrayList<ArrayList<Integer>> ExistedCoveredGraphIds_Edges = new ArrayList<ArrayList<Integer>>();
		//System.out.println("******existingpatterns********");
		for (int i = 0; i < existingpatterns.size(); i++) {
			ExistedPattern.add(existingpatterns.get(i));
			ExistedPatternIndex.add(i);
			Existedsubgraphcoverage.add(existingpr.getSubgraphcoverage().get(i));
			Existedpatternscore.add(existingpr.getPatternscore().get(i));
			ExistedCoveredGraphIds.add(existingpr.getCoveredgraphIDs().get(i));
			ExistedCoveredGraphIds_Edges.add(existingpr.getCoveredgraphids_byEdges().get(i));
			//System.out.println(existingpatterns.get(i) + "," + existingpr.getSubgraphcoverage().get(i) + "," + existingpr.getPatternscore().get(i));
			//System.out.println(existingpr.getCoveredgraphids_byEdges().get(i).toString());
		}
		ArrayList<JGraphtClosureGraph> NewPattern = new ArrayList<JGraphtClosureGraph>();
		ArrayList<Integer> NewPatternIndex = new ArrayList<Integer>();
		ArrayList<Double> Newsubgraphcoverage = new ArrayList<Double>();
		ArrayList<Double> Newpatternscore = new ArrayList<Double>();
		ArrayList<ArrayList<Integer>> NewCoveredGraphIds = new ArrayList<ArrayList<Integer>>();
		ArrayList<ArrayList<Integer>> NewCoveredGraphIds_Edges = new ArrayList<ArrayList<Integer>>();
		//System.out.println("******newpatterns********");
		for (int i = 0; i < newpatterns.size(); i++) {
			NewPattern.add(newpatterns.get(i));
			NewPatternIndex.add(i);
			Newsubgraphcoverage.add(newpr.getSubgraphcoverage().get(i));
			Newpatternscore.add(newpr.getPatternscore().get(i));
			NewCoveredGraphIds.add(newpr.getCoveredgraphIDs().get(i));
			NewCoveredGraphIds_Edges.add(newpr.getCoveredgraphids_byEdges().get(i));
			//System.out.println(newpatterns.get(i) + "," + newpr.getSubgraphcoverage().get(i) + "," + newpr.getPatternscore().get(i));
			//System.out.println(newpr.getCoveredgraphids_byEdges().get(i).toString());
		}
		//System.out.print("size distribution (before):  ");
		ArrayList<Double> InitialSizeDistribution = new ArrayList<Double>();
		ArrayList<Double> UpdateSizeDistribution = new ArrayList<Double>();
		for (int i = 0; i < ExistedPattern.size(); i++) {
			double size = ExistedPattern.get(i).getNumEdges();
			InitialSizeDistribution.add(size);
			UpdateSizeDistribution.add(size);
			//System.out.print(size + ",");
		}
		//System.out.println();

		boolean stop = false;
		boolean popnext = true;
		JGraphtClosureGraph P = null;
		double DynamicKappa = Kappa;
		double DynamicRho_Laststate = getSubgraphCoverageOfPatternSet(ExistedCoveredGraphIds);
		double currentDiv  =  getMinDiversity(ExistedPattern);
		double currentCog = getMinCog(ExistedPattern);
		double currentLcov = getSubgraphCoverageOfPatternSet(ExistedCoveredGraphIds_Edges);
		if (DynamicRho_Laststate < 0.5)
			DynamicKappa = 1 - 2 * DynamicRho_Laststate;
		//System.out.println("DynamicKappa: " + DynamicKappa + " , DynamicRho_Laststate: " + DynamicRho_Laststate);
		int count = 0;
		while (NewPattern.size() > 0 && stop == false) {
			double maxPatternScore_NewPattern = Collections.max(Newpatternscore);
			int index = Newpatternscore.indexOf(maxPatternScore_NewPattern);
			//System.out.println("index:" + index);
			// double CurrentScov = Newsubgraphcoverage.get(index);
			JGraphtClosureGraph Pc = NewPattern.get(index);
			// Newpatternscore.remove(index);
			// Newsubgraphcoverage.remove(index);
			// NewPattern.remove(index);
			double minPatternScore_OldPattern = Collections.min(Existedpatternscore);
			int index2 = Existedpatternscore.indexOf(minPatternScore_OldPattern);
			//System.out.println("index2:" + index2);
			// double CurrentScov2 = Existedsubgraphcoverage.get(index2);
			JGraphtClosureGraph tempP = ExistedPattern.get(index2);
			if (popnext == true)
				P = tempP;
			// 1. get benifit score
			int tempcount = 0;
			Set<Integer> hashSet = new HashSet<Integer>();
			for (int i = 0; i < ExistedCoveredGraphIds.size(); i++)
				for (int j = 0; j < ExistedCoveredGraphIds.get(i).size(); j++)
					hashSet.add(ExistedCoveredGraphIds.get(i).get(j));
			ArrayList<Integer> alreadycovered = new ArrayList<Integer>();
			//System.out.print("alreadycovered:");
			Iterator it = hashSet.iterator();
			while (it.hasNext()) {
				int id = (int) it.next();
				alreadycovered.add(id);
				//System.out.print(id + ",");
			}
			//System.out.println();
			for (int i = 0; i < NewCoveredGraphIds.get(index).size(); i++)
				if (alreadycovered.indexOf(NewCoveredGraphIds.get(index).get(i)) == -1)
					tempcount++;
			//System.out.print("newpatterncovered:");
			//for (int i = 0; i < NewCoveredGraphIds.get(index).size(); i++) {
			//	System.out.print(NewCoveredGraphIds.get(index).get(i) + ",");
			//}
			//System.out.println();
			int BenefitScore = tempcount;
			// 2. get loss score
			tempcount = 0;
			alreadycovered.clear();
			Set<Integer> hashSet2 = new HashSet<Integer>();
			for (int i = 0; i < ExistedCoveredGraphIds.size(); i++)
				if (i != index2)
					for (int j = 0; j < ExistedCoveredGraphIds.get(i).size(); j++)
						hashSet2.add(ExistedCoveredGraphIds.get(i).get(j));
			//System.out.print("alreadycovered without the old pattern:");
			Iterator it2 = hashSet2.iterator();
			while (it2.hasNext()) {
				int id = (int) it2.next();
				alreadycovered.add(id);
				//System.out.print(id + ",");
			}
			//System.out.println();
			//for(int i=0;i<ExistedCoveredGraphIds.size();i++ ) {
			//	System.out.println("i: "+i);
			//	for(int j=0;j< ExistedCoveredGraphIds.get(i).size();j++) {
			//		System.out.print(ExistedCoveredGraphIds.get(i).get(j) + ",");
			//	}
				//System.out.println();
			//}
			//System.out.print("thepatterncovered:");
			for (int i = 0; i < ExistedCoveredGraphIds.get(index2).size(); i++) {
				//System.out.print(ExistedCoveredGraphIds.get(index2).get(i) + ",");
				if (alreadycovered.indexOf(ExistedCoveredGraphIds.get(index2).get(i)) == -1) {
					tempcount++;
				}
			}
			//System.out.println();
			int lossscore = tempcount;
			//System.out.println("BenefitScore :  " + BenefitScore + " ,  LossScore : " + lossscore);
			//System.out.println("maxPatternScore_NewPattern :  " + maxPatternScore_NewPattern + " ,  minPatternScore_OldPattern : " + minPatternScore_OldPattern);
			if (! (BenefitScore < 0.00000001 || maxPatternScore_NewPattern < 0.00000001 ) && BenefitScore >= (1 + DynamicKappa) * lossscore
			 		&& maxPatternScore_NewPattern >= (1 + Lamda_sp) * minPatternScore_OldPattern
					&& !(BenefitScore == lossscore && maxPatternScore_NewPattern == minPatternScore_OldPattern)) {
				//System.out.println("***********SwapTest***********");
				int sizeindex = UpdateSizeDistribution.indexOf((double) P.getNumEdges());
				//System.out.println("sizeindex:"+sizeindex+","+Pc.getNumEdges());
				UpdateSizeDistribution.set(sizeindex, (double) Pc.getNumEdges());
				KSTest newtest = test.TestTwoArrayList(InitialSizeDistribution, UpdateSizeDistribution);
				double distance = newtest.d;
				//System.out.println("distance is : " + distance + " , D_threshold: " + D_threshold);
				boolean isSwapped =  false;
				if(distance <= D_threshold ) {
					ArrayList<JGraphtClosureGraph> tempGraphs = new ArrayList<JGraphtClosureGraph> ();
					for(int k=0;k<UpdatePatterns.size();k++) {
						tempGraphs.add(UpdatePatterns.get(k));
					}
					for(int k = 0; k < ExistedPattern.size();k++) {
						if(k!=index2) 
							tempGraphs.add(ExistedPattern.get(k));
					}
					tempGraphs.add(NewPattern.get(index));
					
					ArrayList<ArrayList<Integer>> tempCoveredGraphIds_edges = new  ArrayList<ArrayList<Integer>> ();
					for(int k=0;k<UpdateGraphId_Edges.size();k++) {
						tempCoveredGraphIds_edges.add(UpdateGraphId_Edges.get(k));
					}
					for(int k = 0; k < ExistedCoveredGraphIds_Edges.size();k++) {
						if(k!=index2) 
							tempCoveredGraphIds_edges.add(ExistedCoveredGraphIds_Edges.get(k));
					}
					tempCoveredGraphIds_edges.add(NewCoveredGraphIds_Edges.get(index));
					double Div  =  getMinDiversity(tempGraphs);
				//	if(Div < (1+Lamda_div)*currentDiv)    continue;
					double Cog = getMinCog(tempGraphs);
				//	if(currentCog*(1+ Lamda_cog) <  Cog  )  continue;
					double Lcov = getSubgraphCoverageOfPatternSet(tempCoveredGraphIds_edges);
				//	if(Lcov < (1+Lamda_lcov) * currentLcov) continue;
					if((Div >= (1+Lamda_div)*currentDiv)  &&   (currentCog*(1+ Lamda_cog) >= Cog  ) && (Lcov >= (1+Lamda_lcov) * currentLcov) ) {
						currentDiv = Div;
						currentCog  = Cog;
						currentLcov  =   Lcov;
						//System.out.println("***********Swap***********");
						UpdatePatterns.add(Pc);
						UpdateGraphId_Edges.add(NewCoveredGraphIds_Edges.get(index));
						Newpatternscore.remove(index);
						Newsubgraphcoverage.remove(index);
						NewPattern.remove(index);
						Existedpatternscore.remove(index2);
						Existedsubgraphcoverage.remove(index2);
						ExistedPattern.remove(index2);
						
						count++;
						popnext = true;
						//System.out.println("***********Swap Parameter***********");
						ExistedCoveredGraphIds.remove(index2);
						ExistedCoveredGraphIds_Edges.remove(index2);
						ExistedCoveredGraphIds.add(NewCoveredGraphIds.get(index));
						ExistedCoveredGraphIds_Edges.add(NewCoveredGraphIds_Edges.get(index));
						NewCoveredGraphIds.remove(index);
						NewCoveredGraphIds_Edges.remove(index);
						DynamicRho_Laststate = getSubgraphCoverageOfPatternSet(ExistedCoveredGraphIds);
						if (DynamicRho_Laststate < 0.5)
							DynamicKappa = 1 - 2 * DynamicRho_Laststate;
						//System.out.println("DynamicKappa: " + DynamicKappa + " , DynamicRho_Laststate: " + DynamicRho_Laststate);
						isSwapped = true;
					}
				}
				if(!isSwapped) {
					// restore
					UpdateSizeDistribution.set(sizeindex, (double) P.getNumEdges());
					Newpatternscore.remove(index);
					Newsubgraphcoverage.remove(index);
					NewPattern.remove(index);
					NewCoveredGraphIds.remove(index);
					NewCoveredGraphIds_Edges.remove(index);
				}
			} else {
				//System.out.println("***********NoSwap***********");
				// UpdatePatterns.add(P);
				// Existedpatternscore.remove(index2);
				// Existedsubgraphcoverage.remove(index2);
				// ExistedPattern.remove(index2);
				Newpatternscore.remove(index);
				Newsubgraphcoverage.remove(index);
				NewPattern.remove(index);
				NewCoveredGraphIds.remove(index);
				NewCoveredGraphIds_Edges.remove(index);
				
				if (maxPatternScore_NewPattern < (1 + Lamda_sp) * minPatternScore_OldPattern)
					stop = true;
				popnext = false;
			}
		}
		//System.out.println("final subgraph coverage rate is : " + getSubgraphCoverageOfPatternSet(ExistedCoveredGraphIds));
		for (int i = 0; i < Existedpatternscore.size(); i++)
			UpdatePatterns.add(ExistedPattern.get(i));
		//System.out.println("Number of swapped patterns : " + count);
		return UpdatePatterns;
	}
	
	public PatternResult calculateUpdatedPatternScore(ArrayList<JGraphtClosureGraph> Patterns,
			ArrayList<Integer> patternIdList, ArrayList<JGraphtClosureGraph> Updated_datagraphs,  Trie trietree) {
		PatternResult result = new PatternResult();
		ArrayList<Double> patternscore = new ArrayList<Double>();
		ArrayList<Double> scovscore = new ArrayList<Double>();
		ArrayList<Double> ged = new ArrayList<Double>();
		ArrayList<Double> cog = new ArrayList<Double>();
		ArrayList<Double> lcov = new ArrayList<Double>();
		ArrayList<ArrayList<Integer>> coveredids = new ArrayList<ArrayList<Integer>>();
		ArrayList<ArrayList<Integer>> coveredids_byedges = new ArrayList<ArrayList<Integer>>();
		for (int i = 0; i < Patterns.size(); i++) {
			//System.out.println("******************" + i + "********************");
			ArrayList<ArrayList<closureEdge>> targetpatterns = new ArrayList<ArrayList<closureEdge>>();
			ArrayList<closureEdge> targetp = new ArrayList<closureEdge>();
			targetp = transJGraphtClosureGraphToclosureEdges(Patterns.get(i));
			//System.out.println("targetp " + targetp.size());
			targetpatterns.add(targetp);
			ArrayList<ArrayList<closureEdge>> otherpatterns = new ArrayList<ArrayList<closureEdge>>();
			for (int j = 0; j < Patterns.size(); j++) {
				if (j == i)
					continue;
				ArrayList<closureEdge> otherp = new ArrayList<closureEdge>();
				otherp = transJGraphtClosureGraphToclosureEdges(Patterns.get(j));
				otherpatterns.add(otherp);
			}
			ArrayList<Integer> pIndex = new ArrayList<Integer>();
			pIndex.add(0);
			ComputeScore cs = new ComputeScore(pIndex, targetpatterns, otherpatterns, patternIdList, Updated_datagraphs,  trietree);
			cs.computeUpdatedScore();
			PatternResult pr = cs.getPatternresult();
			scovscore.add(pr.getSubgraphcoverage().get(0));
			patternscore.add(pr.getPatternscore().get(0));
			coveredids.add(pr.getCoveredgraphIDs().get(0));
			coveredids_byedges.add(pr.getCoveredgraphids_byEdges().get(0));
			ged.add(pr.getGED().get(0));
			cog.add(pr.getCOG().get(0));
			lcov.add(pr.getLCOV().get(0));
		}
		PatternResult pr = new PatternResult();
		pr.setPatternscore(patternscore);
		pr.setSubgraphcoverage(scovscore);
		pr.setCoveredgraphIDs(coveredids);
		pr.setGED(ged);
		pr.setCOG(cog);
		pr.setLCOV(lcov);
		pr.setCoveredgraphids_byEdges(coveredids_byedges);
		return pr;
	}
	public PatternResult calculatePatternScore(ArrayList<JGraphtClosureGraph> Patterns, String FCT_Name, String TG_Name,
			String FEG_Name, String IFEG_Name, String TP_Name, String FEP_Name, String IFEP_Name,
			ArrayList<Integer> patternIdList, ArrayList<JGraphtClosureGraph> Updated_datagraphs) {
		PatternResult result = new PatternResult();
		ArrayList<Double> patternscore = new ArrayList<Double>();
		ArrayList<Double> scovscore = new ArrayList<Double>();
		ArrayList<Double> ged = new ArrayList<Double>();
		ArrayList<Double> cog = new ArrayList<Double>();
		ArrayList<Double> lcov = new ArrayList<Double>();
		ArrayList<ArrayList<Integer>> coveredids = new ArrayList<ArrayList<Integer>>();
		ArrayList<ArrayList<Integer>> coveredids_byedges = new ArrayList<ArrayList<Integer>>();
		for (int i = 0; i < Patterns.size(); i++) {
			System.out.println("******************" + i + "********************");
			ArrayList<ArrayList<closureEdge>> targetpatterns = new ArrayList<ArrayList<closureEdge>>();
			ArrayList<closureEdge> targetp = new ArrayList<closureEdge>();
			targetp = transJGraphtClosureGraphToclosureEdges(Patterns.get(i));
			System.out.println("targetp " + targetp.size());
			targetpatterns.add(targetp);
			ArrayList<ArrayList<closureEdge>> otherpatterns = new ArrayList<ArrayList<closureEdge>>();
			for (int j = 0; j < Patterns.size(); j++) {
				if (j == i)
					continue;
				ArrayList<closureEdge> otherp = new ArrayList<closureEdge>();
				otherp = transJGraphtClosureGraphToclosureEdges(Patterns.get(j));
				otherpatterns.add(otherp);
			}
			ArrayList<Integer> pIndex = new ArrayList<Integer>();
			pIndex.add(0);
			ComputeScore cs = new ComputeScore(pIndex, targetpatterns, otherpatterns, FCT_Name, TG_Name, FEG_Name,
					IFEG_Name, TP_Name, FEP_Name, IFEP_Name, patternIdList, Updated_datagraphs);
			cs.computeScore();
			//cs.computeScore_Updated();
			PatternResult pr = cs.getPatternresult();
			scovscore.add(pr.getSubgraphcoverage().get(0));
			patternscore.add(pr.getPatternscore().get(0));
			coveredids.add(pr.getCoveredgraphIDs().get(0));
			coveredids_byedges.add(pr.getCoveredgraphids_byEdges().get(0));
			ged.add(pr.getGED().get(0));
			cog.add(pr.getCOG().get(0));
			lcov.add(pr.getLCOV().get(0));
			// ArrayList<Double> scores = cs.getCandidatePatternsScore();
			// if(scores.size()!=pIndex.size() ) {
			// System.out.println("*********Error:scores.size()!=pIndex.size()*********");
			// }else {
			// patternscore.add(scores.get(0));
			// }
		}
		PatternResult pr = new PatternResult();
		pr.setPatternscore(patternscore);
		pr.setSubgraphcoverage(scovscore);
		pr.setCoveredgraphIDs(coveredids);
		pr.setGED(ged);
		pr.setCOG(cog);
		pr.setLCOV(lcov);
		pr.setCoveredgraphids_byEdges(coveredids_byedges);
		return pr;
	}
	
	public void UpdatedgeneratePatterns2(Trie  trietree) throws IOException {
		// *********************** Generate GUIPatterns2 *******************************
		System.out.println("**************************Generate UpdatedgeneratePatterns2**************************************************");
		ArrayList<ArrayList<Integer>> original_clusterIDList2 = new ArrayList<ArrayList<Integer>>();// graph ids in //
																									// clusters
		System.out.println("start generating pattern");
		// 1. read the cluster.txt file first
		System.out.println("STEP 1: reading cluster file");
		fullyContainedGraphID2 = new ArrayList<Integer>();
		/// fullyContainedGraphID2
		original_clusterIDList2 = readClusterFile2(UpdateClusterName);
		String filename = DataBaseName;
		int totalGraphs2 = PM_generateClusterClosure2(filename, original_clusterIDList2);
		for (int i = 0; i < original_clusterIDList2.size(); i++)
			c_wt2.add((float) original_clusterIDList2.get(i).size() / (float) maxClosureSize2);
		System.out.println("totalGraphs2 [here]=" + totalGraphs2);
		for (int i = 0; i < DBEdgeLabel2.size(); i++)
			DBEdge_wt2.add((float) DBEdgeLabelFreq2.get(i) / (float) totalGraphs2);
		System.out.println("DBEdgeLabelFreq2=" + DBEdgeLabelFreq2.toString());
		System.out.println("DBEdge_wt2=" + DBEdge_wt2.toString());
		// System.out.println("c_wt: "+c_wt.toString());
		// System.out.println("DBEdge_wt: "+DBEdge_wt.toString());
		// int GUISize=patternSetInfo.getFreqNum();
		ArrayList<Integer> GUIPatternSizeCounter = new ArrayList<Integer>();
		ArrayList<Integer> GUIPatternSize = new ArrayList<Integer>();
		// for(int i=patternSetInfo.getPatternSizeMin();
		// i<=patternSetInfo.getPatternSizeMax(); i++)
		for (int i = minCannedPatternSize2; i <= maxCannedPatternSize2; i++) {
			GUIPatternSize.add(i);
			GUIPatternSizeCounter.add(0);
		}
		boolean PRINT = false;
		for (int g = 0; g < GUISize2; g++) {
			System.out.println("------------------Mining pattern " + (g + 1) + " -----------------------");
			// 3. find first clusters to start with
			// choose candidate clusters containing most freq edge not covered yet
			System.out.println("STEP 3: finding candidate closure");
			Float bestEdgeWt = Collections.max(DBEdge_wt2);
			int bestEdgeIndex = DBEdge_wt2.indexOf(bestEdgeWt);
			String mostFreqEdge = DBEdgeLabel2.get(bestEdgeIndex);
			System.out.println("DBEdgeLabel2: " + DBEdgeLabel2.toString());
			System.out.println("DBEdge_wt2: " + DBEdge_wt2.toString());
			System.out.println("mostFreqEdge2: " + mostFreqEdge + " bestEdgeWt2: " + bestEdgeWt);
			// if(true) return ;
			Long startTime = System.currentTimeMillis();
			ArrayList<Integer> candidateClosureIndex = PM_getCandidateClosureIndex2(mostFreqEdge, 1);// no threading
																										// here
			Long endTime = System.currentTimeMillis();
			System.out.println("get candidate closure index time: " + (endTime - startTime) + " ms");
			System.out.println("candidateClosureIndex2: [" + candidateClosureIndex.size() + "] "
					+ candidateClosureIndex.toString());

			// 4. for each candidate cluster, find the best patterns
			// PM_findBestPatternOfClosure(candidateClosureIndex,
			// patternSetInfo.getPatternSizeMin(), patternSetInfo.getPatternSizeMax(),
			// GUIPatternSize, GUIPatternSizeCounter, GUISize, databaseInfo);
			
			
			//PM_findBestPatternOfClosure2(candidateClosureIndex, minCannedPatternSize2, maxCannedPatternSize2,GUIPatternSize, GUIPatternSizeCounter, GUISize2);

			PM_findBestPatternOfClosure2_Updated(candidateClosureIndex, minCannedPatternSize2, maxCannedPatternSize2,GUIPatternSize, GUIPatternSizeCounter, GUISize2);
			
			System.out.println("candidatePatterns2.size():" + candidatePatterns2.size());
			
			if (candidatePatterns2.size() > 0) {
				// 5. collapse candidatePatterns to distinct ones
				PRINT = true;
				// PM_collapseCandidatePatterns(candidatePatterns,
				// candidatePatterns_closureIndex,
				// patternSetInfo.getPatternSizeMax()-patternSetInfo.getPatternSizeMax()+1,
				// PRINT);
				PM_collapseCandidatePatterns2(candidatePatterns2, candidatePatterns_closureIndex2,
						maxCannedPatternSize2 - minCannedPatternSize2 + 1, PRINT);

				System.out.println("***************START*********************");
				System.out.println("Kai3:" + distinctCandidatePatterns2.size() + "Kai4:"
						+ distinctCandidatePatterns_closureIndex2.size());
				ArrayList<ArrayList<closureEdge>> temp_distinctCandidatePatterns = new ArrayList<ArrayList<closureEdge>>();
				ArrayList<ArrayList<Integer>> temp_distinctCandidatePatterns_closureIndex = new ArrayList<ArrayList<Integer>>();

				for (int k = 0; k < distinctCandidatePatterns2.size(); k++) {
					if (distinctCandidatePatterns2.get(k) != null && k < distinctCandidatePatterns_closureIndex2.size()
							&& distinctCandidatePatterns_closureIndex2.get(k) != null) {
						temp_distinctCandidatePatterns.add(distinctCandidatePatterns2.get(k));
						temp_distinctCandidatePatterns_closureIndex.add(distinctCandidatePatterns_closureIndex2.get(k));
					}
				}
				distinctCandidatePatterns2.clear();
				distinctCandidatePatterns2 = temp_distinctCandidatePatterns;
				distinctCandidatePatterns_closureIndex2.clear();
				distinctCandidatePatterns_closureIndex2 = temp_distinctCandidatePatterns_closureIndex;

				System.out.println("Kai5:" + distinctCandidatePatterns2.size() + "Kai6:"
						+ distinctCandidatePatterns_closureIndex2.size());
				System.out.println("***************END*********************");

				// 6. compute score of distinct candidate patterns:
				// patternScore=clusterWt*(1+GED)
				PM_computePatternScore2_Update(distinctCandidatePatterns2, GUIPatterns2, GUISize2, GUIPatternSize.size(), trietree);

				// 7. find best pattern based on score (highest patternScore)
				// System.out.println("dPattern wt (cluster only):
				// <"+distinctCandidatePatterns_score.size()+">
				// "+distinctCandidatePatterns_score.toString());
				// WriteFile wf=new WriteFile();
				// wf.writeToFile(distinctCandidatePatterns_score);
				int count = 0;
				while (count < distinctCandidatePatterns_score2.size()) {
					if (distinctCandidatePatterns_score2.get(count) == null) {
						distinctCandidatePatterns_score2.remove(count);
						distinctCandidatePatterns2.remove(count);
					} else
						count++;
				}
				System.out.println("distinctCandidatePatterns_score2:" + distinctCandidatePatterns_score2);
				double bestScore = Collections.max(distinctCandidatePatterns_score2);
				int bestPatternIndex = distinctCandidatePatterns_score2.indexOf(bestScore);
				System.out.println("bestPatternIndex2: " + bestPatternIndex);
				ArrayList<closureEdge> bestPattern = distinctCandidatePatterns2.get(bestPatternIndex);
				GUIPatterns2.add(bestPattern);
				int bestPatternSize = bestPattern.size();
				// update GUIPatternSizeCounter
				int patternSize_index = GUIPatternSize.indexOf(bestPatternSize);
				if (patternSize_index != -1)
					GUIPatternSizeCounter.set(patternSize_index, GUIPatternSizeCounter.get(patternSize_index) + 1);
				// System.out.println("bestPattern");
				// for(int i=0; i<bestPattern.size(); i++)
				// bestPattern.get(i).print();

				// 8. update weights of edge label and clusters based on best pattern selected
				PM_updateWeights2(bestPattern, distinctCandidatePatterns_closureIndex2.get(bestPatternIndex));
			} else
				g = GUISize2;
		}
		
		
		ArrayList<ArrayList<closureEdge>>  Patterns =  new ArrayList<ArrayList<closureEdge>>();
		for(int i=0;i<GUIPatterns2.size();i++) {
			if(GUIPatterns2.get(i) !=null && GUIPatterns2.get(i).size()>0) {
				Patterns.add(GUIPatterns2.get(i));
			}
		}
		
		// process database-END
		String pathToSaveImage = PM_resetThumbnailFolder2();
		PM_generateThumbnails(pathToSaveImage, Patterns, dbName);
		PM_loadThumbnails(pathToSaveImage);
		PM_savePatternsToFile(pathToSaveImage, Patterns);
	}
	
	public void UpdatedgeneratePatterns2() throws IOException {

		// *********************** Generate GUIPatterns2 *******************************
		System.out.println("**************************Generate UpdatedgeneratePatterns2**************************************************");
		ArrayList<ArrayList<Integer>> original_clusterIDList2 = new ArrayList<ArrayList<Integer>>();// graph ids in //
																									// clusters
		System.out.println("start generating pattern");
		// 1. read the cluster.txt file first
		System.out.println("STEP 1: reading cluster file");
		fullyContainedGraphID2 = new ArrayList<Integer>();
		/// fullyContainedGraphID2
		original_clusterIDList2 = readClusterFile2(UpdateClusterName);
		String filename = DataBaseName;
		int totalGraphs2 = PM_generateClusterClosure2(filename, original_clusterIDList2);
		for (int i = 0; i < original_clusterIDList2.size(); i++)
			c_wt2.add((float) original_clusterIDList2.get(i).size() / (float) maxClosureSize2);
		System.out.println("totalGraphs2 [here]=" + totalGraphs2);
		for (int i = 0; i < DBEdgeLabel2.size(); i++)
			DBEdge_wt2.add((float) DBEdgeLabelFreq2.get(i) / (float) totalGraphs2);
		System.out.println("DBEdgeLabelFreq2=" + DBEdgeLabelFreq2.toString());
		System.out.println("DBEdge_wt2=" + DBEdge_wt2.toString());
		// System.out.println("c_wt: "+c_wt.toString());
		// System.out.println("DBEdge_wt: "+DBEdge_wt.toString());
		// int GUISize=patternSetInfo.getFreqNum();
		ArrayList<Integer> GUIPatternSizeCounter = new ArrayList<Integer>();
		ArrayList<Integer> GUIPatternSize = new ArrayList<Integer>();
		// for(int i=patternSetInfo.getPatternSizeMin();
		// i<=patternSetInfo.getPatternSizeMax(); i++)
		for (int i = minCannedPatternSize2; i <= maxCannedPatternSize2; i++) {
			GUIPatternSize.add(i);
			GUIPatternSizeCounter.add(0);
		}
		boolean PRINT = false;
		for (int g = 0; g < GUISize2; g++) {
			System.out.println("------------------Mining pattern " + (g + 1) + " -----------------------");
			// 3. find first clusters to start with
			// choose candidate clusters containing most freq edge not covered yet
			System.out.println("STEP 3: finding candidate closure");
			Float bestEdgeWt = Collections.max(DBEdge_wt2);
			int bestEdgeIndex = DBEdge_wt2.indexOf(bestEdgeWt);
			String mostFreqEdge = DBEdgeLabel2.get(bestEdgeIndex);
			System.out.println("DBEdgeLabel2: " + DBEdgeLabel2.toString());
			System.out.println("DBEdge_wt2: " + DBEdge_wt2.toString());
			System.out.println("mostFreqEdge2: " + mostFreqEdge + " bestEdgeWt2: " + bestEdgeWt);
			// if(true) return ;
			Long startTime = System.currentTimeMillis();
			ArrayList<Integer> candidateClosureIndex = PM_getCandidateClosureIndex2(mostFreqEdge, 1);// no threading
																										// here
			Long endTime = System.currentTimeMillis();
			System.out.println("get candidate closure index time: " + (endTime - startTime) + " ms");
			System.out.println("candidateClosureIndex2: [" + candidateClosureIndex.size() + "] "
					+ candidateClosureIndex.toString());

			// 4. for each candidate cluster, find the best patterns
			// PM_findBestPatternOfClosure(candidateClosureIndex,
			// patternSetInfo.getPatternSizeMin(), patternSetInfo.getPatternSizeMax(),
			// GUIPatternSize, GUIPatternSizeCounter, GUISize, databaseInfo);
			
			
			//PM_findBestPatternOfClosure2(candidateClosureIndex, minCannedPatternSize2, maxCannedPatternSize2,GUIPatternSize, GUIPatternSizeCounter, GUISize2);

			PM_findBestPatternOfClosure2_Updated(candidateClosureIndex, minCannedPatternSize2, maxCannedPatternSize2,GUIPatternSize, GUIPatternSizeCounter, GUISize2);
			
			System.out.println("candidatePatterns2.size():" + candidatePatterns2.size());
			
			if (candidatePatterns2.size() > 0) {
				// 5. collapse candidatePatterns to distinct ones
				PRINT = true;
				// PM_collapseCandidatePatterns(candidatePatterns,
				// candidatePatterns_closureIndex,
				// patternSetInfo.getPatternSizeMax()-patternSetInfo.getPatternSizeMax()+1,
				// PRINT);
				PM_collapseCandidatePatterns2(candidatePatterns2, candidatePatterns_closureIndex2,
						maxCannedPatternSize2 - minCannedPatternSize2 + 1, PRINT);

				System.out.println("***************START*********************");
				System.out.println("Kai3:" + distinctCandidatePatterns2.size() + "Kai4:"
						+ distinctCandidatePatterns_closureIndex2.size());
				ArrayList<ArrayList<closureEdge>> temp_distinctCandidatePatterns = new ArrayList<ArrayList<closureEdge>>();
				ArrayList<ArrayList<Integer>> temp_distinctCandidatePatterns_closureIndex = new ArrayList<ArrayList<Integer>>();

				for (int k = 0; k < distinctCandidatePatterns2.size(); k++) {
					if (distinctCandidatePatterns2.get(k) != null && k < distinctCandidatePatterns_closureIndex2.size()
							&& distinctCandidatePatterns_closureIndex2.get(k) != null) {
						temp_distinctCandidatePatterns.add(distinctCandidatePatterns2.get(k));
						temp_distinctCandidatePatterns_closureIndex.add(distinctCandidatePatterns_closureIndex2.get(k));
					}
				}
				distinctCandidatePatterns2.clear();
				distinctCandidatePatterns2 = temp_distinctCandidatePatterns;
				distinctCandidatePatterns_closureIndex2.clear();
				distinctCandidatePatterns_closureIndex2 = temp_distinctCandidatePatterns_closureIndex;

				System.out.println("Kai5:" + distinctCandidatePatterns2.size() + "Kai6:"
						+ distinctCandidatePatterns_closureIndex2.size());
				System.out.println("***************END*********************");

				// 6. compute score of distinct candidate patterns:
				// patternScore=clusterWt*(1+GED)
				PM_computePatternScore2(distinctCandidatePatterns2, GUIPatterns2, GUISize2, GUIPatternSize.size());

				// 7. find best pattern based on score (highest patternScore)
				// System.out.println("dPattern wt (cluster only):
				// <"+distinctCandidatePatterns_score.size()+">
				// "+distinctCandidatePatterns_score.toString());
				// WriteFile wf=new WriteFile();
				// wf.writeToFile(distinctCandidatePatterns_score);
				int count = 0;
				while (count < distinctCandidatePatterns_score2.size()) {
					if (distinctCandidatePatterns_score2.get(count) == null) {
						distinctCandidatePatterns_score2.remove(count);
						distinctCandidatePatterns2.remove(count);
					} else
						count++;
				}
				System.out.println("distinctCandidatePatterns_score2:" + distinctCandidatePatterns_score2);
				double bestScore = Collections.max(distinctCandidatePatterns_score2);
				int bestPatternIndex = distinctCandidatePatterns_score2.indexOf(bestScore);
				System.out.println("bestPatternIndex2: " + bestPatternIndex);
				ArrayList<closureEdge> bestPattern = distinctCandidatePatterns2.get(bestPatternIndex);
				GUIPatterns2.add(bestPattern);
				int bestPatternSize = bestPattern.size();
				// update GUIPatternSizeCounter
				int patternSize_index = GUIPatternSize.indexOf(bestPatternSize);
				if (patternSize_index != -1)
					GUIPatternSizeCounter.set(patternSize_index, GUIPatternSizeCounter.get(patternSize_index) + 1);
				// System.out.println("bestPattern");
				// for(int i=0; i<bestPattern.size(); i++)
				// bestPattern.get(i).print();

				// 8. update weights of edge label and clusters based on best pattern selected
				PM_updateWeights2(bestPattern, distinctCandidatePatterns_closureIndex2.get(bestPatternIndex));
			} else
				g = GUISize2;
		}
		
		
		ArrayList<ArrayList<closureEdge>>  Patterns =  new ArrayList<ArrayList<closureEdge>>();
		for(int i=0;i<GUIPatterns2.size();i++) {
			if(GUIPatterns2.get(i) !=null && GUIPatterns2.get(i).size()>0) {
				Patterns.add(GUIPatterns2.get(i));
			}
		}
		
		// process database-END
		String pathToSaveImage = PM_resetThumbnailFolder2();
		PM_generateThumbnails(pathToSaveImage, Patterns, dbName);
		PM_loadThumbnails(pathToSaveImage);
		PM_savePatternsToFile(pathToSaveImage, Patterns);
	}

	public void generatePatterns2() throws IOException {

		// *********************** Generate GUIPatterns2 *******************************
		System.out.println(
				"**************************Generate GUIPatterns2**************************************************");
		ArrayList<ArrayList<Integer>> original_clusterIDList2 = new ArrayList<ArrayList<Integer>>();// graph ids in //
																									// clusters
		System.out.println("start generating pattern");
		// 1. read the cluster.txt file first
		System.out.println("STEP 1: reading cluster file");
		fullyContainedGraphID2 = new ArrayList<Integer>();
		/// fullyContainedGraphID2
		original_clusterIDList2 = readClusterFile2(UpdateClusterName);
		String filename = DataBaseName;
		int totalGraphs2 = PM_generateClusterClosure2(filename, original_clusterIDList2);
		for (int i = 0; i < original_clusterIDList2.size(); i++)
			c_wt2.add((float) original_clusterIDList2.get(i).size() / (float) maxClosureSize2);
		System.out.println("totalGraphs2 [here]=" + totalGraphs2);
		for (int i = 0; i < DBEdgeLabel2.size(); i++)
			DBEdge_wt2.add((float) DBEdgeLabelFreq2.get(i) / (float) totalGraphs2);
		System.out.println("DBEdgeLabelFreq2=" + DBEdgeLabelFreq2.toString());
		System.out.println("DBEdge_wt2=" + DBEdge_wt2.toString());
		// System.out.println("c_wt: "+c_wt.toString());
		// System.out.println("DBEdge_wt: "+DBEdge_wt.toString());
		// int GUISize=patternSetInfo.getFreqNum();
		ArrayList<Integer> GUIPatternSizeCounter = new ArrayList<Integer>();
		ArrayList<Integer> GUIPatternSize = new ArrayList<Integer>();
		// for(int i=patternSetInfo.getPatternSizeMin();
		// i<=patternSetInfo.getPatternSizeMax(); i++)
		for (int i = minCannedPatternSize2; i <= maxCannedPatternSize2; i++) {
			GUIPatternSize.add(i);
			GUIPatternSizeCounter.add(0);
		}
		boolean PRINT = false;
		for (int g = 0; g < GUISize2; g++) {
			System.out.println("------------------Mining pattern " + (g + 1) + " -----------------------");
			// 3. find first clusters to start with
			// choose candidate clusters containing most freq edge not covered yet
			System.out.println("STEP 3: finding candidate closure");
			Float bestEdgeWt = Collections.max(DBEdge_wt2);
			int bestEdgeIndex = DBEdge_wt2.indexOf(bestEdgeWt);
			String mostFreqEdge = DBEdgeLabel2.get(bestEdgeIndex);
			System.out.println("DBEdgeLabel2: " + DBEdgeLabel2.toString());
			System.out.println("DBEdge_wt2: " + DBEdge_wt2.toString());
			System.out.println("mostFreqEdge2: " + mostFreqEdge + " bestEdgeWt2: " + bestEdgeWt);
			// if(true) return ;
			Long startTime = System.currentTimeMillis();
			ArrayList<Integer> candidateClosureIndex = PM_getCandidateClosureIndex2(mostFreqEdge, 1);// no threading
																										// here
			Long endTime = System.currentTimeMillis();
			System.out.println("get candidate closure index time: " + (endTime - startTime) + " ms");
			System.out.println("candidateClosureIndex2: [" + candidateClosureIndex.size() + "] "
					+ candidateClosureIndex.toString());

			// 4. for each candidate cluster, find the best patterns
			// PM_findBestPatternOfClosure(candidateClosureIndex,
			// patternSetInfo.getPatternSizeMin(), patternSetInfo.getPatternSizeMax(),
			// GUIPatternSize, GUIPatternSizeCounter, GUISize, databaseInfo);
			PM_findBestPatternOfClosure2(candidateClosureIndex, minCannedPatternSize2, maxCannedPatternSize2,
					GUIPatternSize, GUIPatternSizeCounter, GUISize2);

			if (candidatePatterns2.size() > 0) {
				// 5. collapse candidatePatterns to distinct ones
				PRINT = true;
				// PM_collapseCandidatePatterns(candidatePatterns,
				// candidatePatterns_closureIndex,
				// patternSetInfo.getPatternSizeMax()-patternSetInfo.getPatternSizeMax()+1,
				// PRINT);
				PM_collapseCandidatePatterns2(candidatePatterns2, candidatePatterns_closureIndex2,
						maxCannedPatternSize2 - minCannedPatternSize2 + 1, PRINT);

				System.out.println("***************START*********************");
				System.out.println("Kai3:" + distinctCandidatePatterns2.size() + "Kai4:"
						+ distinctCandidatePatterns_closureIndex2.size());
				ArrayList<ArrayList<closureEdge>> temp_distinctCandidatePatterns = new ArrayList<ArrayList<closureEdge>>();
				ArrayList<ArrayList<Integer>> temp_distinctCandidatePatterns_closureIndex = new ArrayList<ArrayList<Integer>>();

				for (int k = 0; k < distinctCandidatePatterns2.size(); k++) {
					if (distinctCandidatePatterns2.get(k) != null && k < distinctCandidatePatterns_closureIndex2.size()
							&& distinctCandidatePatterns_closureIndex2.get(k) != null) {
						temp_distinctCandidatePatterns.add(distinctCandidatePatterns2.get(k));
						temp_distinctCandidatePatterns_closureIndex.add(distinctCandidatePatterns_closureIndex2.get(k));
					}
				}
				distinctCandidatePatterns2.clear();
				distinctCandidatePatterns2 = temp_distinctCandidatePatterns;
				distinctCandidatePatterns_closureIndex2.clear();
				distinctCandidatePatterns_closureIndex2 = temp_distinctCandidatePatterns_closureIndex;

				System.out.println("Kai5:" + distinctCandidatePatterns2.size() + "Kai6:"
						+ distinctCandidatePatterns_closureIndex2.size());
				System.out.println("***************END*********************");

				// 6. compute score of distinct candidate patterns:
				// patternScore=clusterWt*(1+GED)
				PM_computePatternScore2(distinctCandidatePatterns2, GUIPatterns2, GUISize2, GUIPatternSize.size());

				// 7. find best pattern based on score (highest patternScore)
				// System.out.println("dPattern wt (cluster only):
				// <"+distinctCandidatePatterns_score.size()+">
				// "+distinctCandidatePatterns_score.toString());
				// WriteFile wf=new WriteFile();
				// wf.writeToFile(distinctCandidatePatterns_score);
				int count = 0;
				while (count < distinctCandidatePatterns_score2.size()) {
					if (distinctCandidatePatterns_score2.get(count) == null) {
						distinctCandidatePatterns_score2.remove(count);
						distinctCandidatePatterns2.remove(count);
					} else
						count++;
				}
				System.out.println("distinctCandidatePatterns_score2:" + distinctCandidatePatterns_score2);
				double bestScore = Collections.max(distinctCandidatePatterns_score2);
				int bestPatternIndex = distinctCandidatePatterns_score2.indexOf(bestScore);
				System.out.println("bestPatternIndex2: " + bestPatternIndex);
				ArrayList<closureEdge> bestPattern = distinctCandidatePatterns2.get(bestPatternIndex);
				GUIPatterns2.add(bestPattern);
				int bestPatternSize = bestPattern.size();
				// update GUIPatternSizeCounter
				int patternSize_index = GUIPatternSize.indexOf(bestPatternSize);
				if (patternSize_index != -1)
					GUIPatternSizeCounter.set(patternSize_index, GUIPatternSizeCounter.get(patternSize_index) + 1);
				// System.out.println("bestPattern");
				// for(int i=0; i<bestPattern.size(); i++)
				// bestPattern.get(i).print();

				// 8. update weights of edge label and clusters based on best pattern selected
				PM_updateWeights2(bestPattern, distinctCandidatePatterns_closureIndex2.get(bestPatternIndex));
			} else
				g = GUISize2;
		}
		// process database-END
		String pathToSaveImage = PM_resetThumbnailFolder2();
		PM_generateThumbnails(pathToSaveImage, GUIPatterns2, dbName);
		PM_loadThumbnails(pathToSaveImage);
		PM_savePatternsToFile(pathToSaveImage, GUIPatterns2);
	}
	
	public void generatePatternsWithTrie() throws IOException {

		// *********************** Generate GUIPatternsWithTrie*******************************
		System.out.println(
				"**************************Generate GUIPatternsWithTrie**************************************************");
		ArrayList<ArrayList<Integer>> original_clusterIDList2 = new ArrayList<ArrayList<Integer>>();// graph ids in //
																									// clusters
		System.out.println("start generating pattern");
		// 1. read the cluster.txt file first
		System.out.println("STEP 1: reading cluster file");
		fullyContainedGraphID2 = new ArrayList<Integer>();
		/// fullyContainedGraphID2
		original_clusterIDList2 = readClusterFile2(UpdateClusterName);
		String filename = DataBaseName;
		int totalGraphs2 = PM_generateClusterClosure2(filename, original_clusterIDList2);
		for (int i = 0; i < original_clusterIDList2.size(); i++)
			c_wt2.add((float) original_clusterIDList2.get(i).size() / (float) maxClosureSize2);
		System.out.println("totalGraphs2 [here]=" + totalGraphs2);
		for (int i = 0; i < DBEdgeLabel2.size(); i++)
			DBEdge_wt2.add((float) DBEdgeLabelFreq2.get(i) / (float) totalGraphs2);
		System.out.println("DBEdgeLabelFreq2=" + DBEdgeLabelFreq2.toString());
		System.out.println("DBEdge_wt2=" + DBEdge_wt2.toString());
		// System.out.println("c_wt: "+c_wt.toString());
		// System.out.println("DBEdge_wt: "+DBEdge_wt.toString());
		// int GUISize=patternSetInfo.getFreqNum();
		ArrayList<Integer> GUIPatternSizeCounter = new ArrayList<Integer>();
		ArrayList<Integer> GUIPatternSize = new ArrayList<Integer>();
		// for(int i=patternSetInfo.getPatternSizeMin();
		// i<=patternSetInfo.getPatternSizeMax(); i++)
		for (int i = minCannedPatternSize2; i <= maxCannedPatternSize2; i++) {
			GUIPatternSize.add(i);
			GUIPatternSizeCounter.add(0);
		}
		boolean PRINT = false;
		for (int g = 0; g < GUISize2; g++) {
			System.out.println("------------------Mining pattern " + (g + 1) + " -----------------------");
			// 3. find first clusters to start with
			// choose candidate clusters containing most freq edge not covered yet
			System.out.println("STEP 3: finding candidate closure");
			Float bestEdgeWt = Collections.max(DBEdge_wt2);
			int bestEdgeIndex = DBEdge_wt2.indexOf(bestEdgeWt);
			String mostFreqEdge = DBEdgeLabel2.get(bestEdgeIndex);
			System.out.println("DBEdgeLabel2: " + DBEdgeLabel2.toString());
			System.out.println("DBEdge_wt2: " + DBEdge_wt2.toString());
			System.out.println("mostFreqEdge2: " + mostFreqEdge + " bestEdgeWt2: " + bestEdgeWt);
			// if(true) return ;
			Long startTime = System.currentTimeMillis();
			ArrayList<Integer> candidateClosureIndex = PM_getCandidateClosureIndex2(mostFreqEdge, 1);// no threading
																										// here
			Long endTime = System.currentTimeMillis();
			System.out.println("get candidate closure index time: " + (endTime - startTime) + " ms");
			System.out.println("candidateClosureIndex2: [" + candidateClosureIndex.size() + "] "
					+ candidateClosureIndex.toString());

			// 4. for each candidate cluster, find the best patterns
			// PM_findBestPatternOfClosure(candidateClosureIndex,
			// patternSetInfo.getPatternSizeMin(), patternSetInfo.getPatternSizeMax(),
			// GUIPatternSize, GUIPatternSizeCounter, GUISize, databaseInfo);
			PM_findBestPatternOfClosure2(candidateClosureIndex, minCannedPatternSize2, maxCannedPatternSize2,
					GUIPatternSize, GUIPatternSizeCounter, GUISize2);

			if (candidatePatterns2.size() > 0) {
				// 5. collapse candidatePatterns to distinct ones
				PRINT = true;
				// PM_collapseCandidatePatterns(candidatePatterns,
				// candidatePatterns_closureIndex,
				// patternSetInfo.getPatternSizeMax()-patternSetInfo.getPatternSizeMax()+1,
				// PRINT);
				PM_collapseCandidatePatterns2(candidatePatterns2, candidatePatterns_closureIndex2,
						maxCannedPatternSize2 - minCannedPatternSize2 + 1, PRINT);

				System.out.println("***************START*********************");
				System.out.println("Kai3:" + distinctCandidatePatterns2.size() + "Kai4:"
						+ distinctCandidatePatterns_closureIndex2.size());
				ArrayList<ArrayList<closureEdge>> temp_distinctCandidatePatterns = new ArrayList<ArrayList<closureEdge>>();
				ArrayList<ArrayList<Integer>> temp_distinctCandidatePatterns_closureIndex = new ArrayList<ArrayList<Integer>>();

				for (int k = 0; k < distinctCandidatePatterns2.size(); k++) {
					if (distinctCandidatePatterns2.get(k) != null && k < distinctCandidatePatterns_closureIndex2.size()
							&& distinctCandidatePatterns_closureIndex2.get(k) != null) {
						temp_distinctCandidatePatterns.add(distinctCandidatePatterns2.get(k));
						temp_distinctCandidatePatterns_closureIndex.add(distinctCandidatePatterns_closureIndex2.get(k));
					}
				}
				distinctCandidatePatterns2.clear();
				distinctCandidatePatterns2 = temp_distinctCandidatePatterns;
				distinctCandidatePatterns_closureIndex2.clear();
				distinctCandidatePatterns_closureIndex2 = temp_distinctCandidatePatterns_closureIndex;

				System.out.println("Kai5:" + distinctCandidatePatterns2.size() + "Kai6:"
						+ distinctCandidatePatterns_closureIndex2.size());
				System.out.println("***************END*********************");

				// 6. compute score of distinct candidate patterns:
				// patternScore=clusterWt*(1+GED)
				PM_computePatternScore2(distinctCandidatePatterns2, GUIPatterns2, GUISize2, GUIPatternSize.size());

				// 7. find best pattern based on score (highest patternScore)
				// System.out.println("dPattern wt (cluster only):
				// <"+distinctCandidatePatterns_score.size()+">
				// "+distinctCandidatePatterns_score.toString());
				// WriteFile wf=new WriteFile();
				// wf.writeToFile(distinctCandidatePatterns_score);
				int count = 0;
				while (count < distinctCandidatePatterns_score2.size()) {
					if (distinctCandidatePatterns_score2.get(count) == null) {
						distinctCandidatePatterns_score2.remove(count);
						distinctCandidatePatterns2.remove(count);
					} else
						count++;
				}
				System.out.println("distinctCandidatePatterns_score2:" + distinctCandidatePatterns_score2);
				double bestScore = Collections.max(distinctCandidatePatterns_score2);
				int bestPatternIndex = distinctCandidatePatterns_score2.indexOf(bestScore);
				System.out.println("bestPatternIndex2: " + bestPatternIndex);
				ArrayList<closureEdge> bestPattern = distinctCandidatePatterns2.get(bestPatternIndex);
				GUIPatterns2.add(bestPattern);
				int bestPatternSize = bestPattern.size();
				// update GUIPatternSizeCounter
				int patternSize_index = GUIPatternSize.indexOf(bestPatternSize);
				if (patternSize_index != -1)
					GUIPatternSizeCounter.set(patternSize_index, GUIPatternSizeCounter.get(patternSize_index) + 1);
				// System.out.println("bestPattern");
				// for(int i=0; i<bestPattern.size(); i++)
				// bestPattern.get(i).print();

				// 8. update weights of edge label and clusters based on best pattern selected
				PM_updateWeights2(bestPattern, distinctCandidatePatterns_closureIndex2.get(bestPatternIndex));
			} else
				g = GUISize2;
		}
		// process database-END
		String pathToSaveImage = PM_resetThumbnailFolder2();
		PM_generateThumbnails(pathToSaveImage, GUIPatterns2, dbName);
		PM_loadThumbnails(pathToSaveImage);
		PM_savePatternsToFile(pathToSaveImage, GUIPatterns2);
	}
	
	public void generatePatternsWithIndex() throws IOException {

		// *********************** Generate GUIPatterns *******************************
		System.out.println("*********************** Generate GUIPatterns *******************************");
		ArrayList<ArrayList<Integer>> original_clusterIDList = new ArrayList<ArrayList<Integer>>();// graph ids in
																									// clusters
		System.out.println("start generating pattern");
		Long generatePatternStartTime = System.currentTimeMillis();
		{
			// 1. read the cluster.txt file first
			System.out.println("STEP 1: reading cluster file");
			fullyContainedGraphID = new ArrayList<Integer>();
			/// read clusters into original_clusterIDList, and stores all graphid into
			/// fullyContainedGraphID
			original_clusterIDList = readClusterFile(InitialClusterName);
			String filename = DataBaseName;
			int totalGraphs = PM_generateClusterClosure(filename, original_clusterIDList);
			for (int i = 0; i < original_clusterIDList.size(); i++)
				c_wt.add((float) original_clusterIDList.get(i).size() / (float) maxClosureSize);
			System.out.println("totalGraphs [here]=" + totalGraphs);
			for (int i = 0; i < DBEdgeLabel.size(); i++)
				DBEdge_wt.add((float) DBEdgeLabelFreq.get(i) / (float) totalGraphs);
			System.out.println("DBEdgeLabelFreq=" + DBEdgeLabelFreq.toString());
			System.out.println("DBEdge_wt=" + DBEdge_wt.toString());

			ArrayList<Integer> GUIPatternSizeCounter = new ArrayList<Integer>();
			ArrayList<Integer> GUIPatternSize = new ArrayList<Integer>();
			// for(int i=patternSetInfo.getPatternSizeMin();
			// i<=patternSetInfo.getPatternSizeMax(); i++)
			for (int i = minCannedPatternSize; i <= maxCannedPatternSize; i++) {
				GUIPatternSize.add(i);
				GUIPatternSizeCounter.add(0);
			}
			boolean PRINT = false;
			for (int g = 0; g < GUISize; g++) {
				System.out.println("------------------Mining pattern " + (g + 1) + " -----------------------");
				// 3. find first clusters to start with
				// choose candidate clusters containing most freq edge not covered yet
				System.out.println("STEP 3: finding candidate closure");
				Float bestEdgeWt = Collections.max(DBEdge_wt);
				int bestEdgeIndex = DBEdge_wt.indexOf(bestEdgeWt);
				String mostFreqEdge = DBEdgeLabel.get(bestEdgeIndex);
				System.out.println("DBEdgeLabel: " + DBEdgeLabel.toString());
				System.out.println("DBEdge_wt: " + DBEdge_wt.toString());
				System.out.println("mostFreqEdge: " + mostFreqEdge + " bestEdgeWt: " + bestEdgeWt);
				// if(true) return ;
				Long startTime = System.currentTimeMillis();
				ArrayList<Integer> candidateClosureIndex = PM_getCandidateClosureIndex(mostFreqEdge, 1);// no
																										// threading
																										// here
				Long endTime = System.currentTimeMillis();
				System.out.println("get candidate closure index time: " + (endTime - startTime) + " ms");
				System.out.println("candidateClosureIndex: [" + candidateClosureIndex.size() + "] "
						+ candidateClosureIndex.toString());

				// 4. for each candidate cluster, find the best patterns
				// PM_findBestPatternOfClosure(candidateClosureIndex,
				// patternSetInfo.getPatternSizeMin(), patternSetInfo.getPatternSizeMax(),
				// GUIPatternSize, GUIPatternSizeCounter, GUISize, databaseInfo);
				PM_findBestPatternOfClosure(candidateClosureIndex, minCannedPatternSize, maxCannedPatternSize,
						GUIPatternSize, GUIPatternSizeCounter, GUISize);

				if (candidatePatterns.size() > 0) {
					// 5. collapse candidatePatterns to distinct ones
					PRINT = true;

					//////// Remove duplicated patterns , input is candidatePatterns, output is
					//////// distinctCandidatePatterns

					// PM_collapseCandidatePatterns(candidatePatterns,
					// candidatePatterns_closureIndex,
					// patternSetInfo.getPatternSizeMax()-patternSetInfo.getPatternSizeMax()+1,
					// PRINT);
					PM_collapseCandidatePatterns(candidatePatterns, candidatePatterns_closureIndex,
							maxCannedPatternSize - minCannedPatternSize + 1, PRINT);

					System.out.println("***************START*********************");
					System.out.println("size1:" + candidatePatterns.size());
					for (int k = 0; k < candidatePatterns.size(); k++) {
						for (int k2 = 0; k2 < candidatePatterns.get(k).size(); k2++) {
							candidatePatterns.get(k).get(k2).print();
						}
						System.out.println();
					}
					System.out.println();
					System.out.println("size2:" + candidatePatterns_closureIndex.size());
					for (int k = 0; k < candidatePatterns_closureIndex.size(); k++) {
						System.out.print(candidatePatterns_closureIndex.get(k) + ";");
					}
					System.out.println();

					System.out.println("Kai3:" + distinctCandidatePatterns.size() + "Kai4:"
							+ distinctCandidatePatterns_closureIndex.size());
					ArrayList<ArrayList<closureEdge>> temp_distinctCandidatePatterns = new ArrayList<ArrayList<closureEdge>>();
					ArrayList<ArrayList<Integer>> temp_distinctCandidatePatterns_closureIndex = new ArrayList<ArrayList<Integer>>();

					for (int k = 0; k < distinctCandidatePatterns.size(); k++) {
						if (distinctCandidatePatterns.get(k) != null
								&& k < distinctCandidatePatterns_closureIndex.size()
								&& distinctCandidatePatterns_closureIndex.get(k) != null) {
							temp_distinctCandidatePatterns.add(distinctCandidatePatterns.get(k));
							temp_distinctCandidatePatterns_closureIndex
									.add(distinctCandidatePatterns_closureIndex.get(k));
						}
					}
					distinctCandidatePatterns.clear();
					distinctCandidatePatterns = temp_distinctCandidatePatterns;
					distinctCandidatePatterns_closureIndex.clear();
					distinctCandidatePatterns_closureIndex = temp_distinctCandidatePatterns_closureIndex;

					System.out.println("Kai5:" + distinctCandidatePatterns.size() + "Kai6:"
							+ distinctCandidatePatterns_closureIndex.size());

					/*
					 * System.out.println("size3:"+distinctCandidatePatterns.size());
					 * ArrayList<ArrayList<closureEdge>> temp_distinctCandidatePatterns = new
					 * ArrayList<ArrayList<closureEdge>>(); for(int
					 * k=0;k<distinctCandidatePatterns.size();k++) {
					 * if(distinctCandidatePatterns.get(k) != null) {
					 * temp_distinctCandidatePatterns.add(distinctCandidatePatterns.get(k)); } }
					 * distinctCandidatePatterns.clear(); distinctCandidatePatterns =
					 * temp_distinctCandidatePatterns;
					 * 
					 * System.out.println();
					 * System.out.println("size4:"+distinctCandidatePatterns_closureIndex.size());
					 * ArrayList<ArrayList<Integer>> temp_distinctCandidatePatterns_closureIndex =
					 * new ArrayList<ArrayList<Integer>>(); for(int
					 * k=0;k<distinctCandidatePatterns_closureIndex.size();k++) {
					 * if(distinctCandidatePatterns_closureIndex.get(k) != null)
					 * temp_distinctCandidatePatterns_closureIndex.add(
					 * distinctCandidatePatterns_closureIndex.get(k) ); }
					 * distinctCandidatePatterns_closureIndex.clear();
					 * distinctCandidatePatterns_closureIndex =
					 * temp_distinctCandidatePatterns_closureIndex; System.out.println();
					 * 
					 * System.out.println("Kai5:"+distinctCandidatePatterns.size()+
					 * "Kai6:"+distinctCandidatePatterns_closureIndex.size());
					 */
					System.out.println("***************END*********************");

					// System.out.println("*****PM_computePatternScore1*****");
					// 6. compute score of distinct candidate patterns:
					// patternScore=clusterWt*(1+GED)
					PM_computePatternScore(distinctCandidatePatterns, GUIPatterns, GUISize, GUIPatternSize.size());
					// System.out.println("*****PM_computePatternScore2*****");
					// 7. find best pattern based on score (highest patternScore)
					// System.out.println("dPattern wt (cluster only):
					// <"+distinctCandidatePatterns_score.size()+">
					// "+distinctCandidatePatterns_score.toString());
					// WriteFile wf=new WriteFile();
					// wf.writeToFile(distinctCandidatePatterns_score);
					int count = 0;
					while (count < distinctCandidatePatterns_score.size()) {
						if (distinctCandidatePatterns_score.get(count) == null) {
							distinctCandidatePatterns_score.remove(count);
							distinctCandidatePatterns.remove(count);
						} else
							count++;
					}
					double bestScore = Collections.max(distinctCandidatePatterns_score);
					int bestPatternIndex = distinctCandidatePatterns_score.indexOf(bestScore);
					System.out.println("bestPatternIndex: " + bestPatternIndex);
					ArrayList<closureEdge> bestPattern = distinctCandidatePatterns.get(bestPatternIndex);
					/////// All patterns are stored in GUIPatterns //////////////////////////
					GUIPatterns.add(bestPattern);
					int bestPatternSize = bestPattern.size();
					// update GUIPatternSizeCounter
					int patternSize_index = GUIPatternSize.indexOf(bestPatternSize);
					if (patternSize_index != -1)
						GUIPatternSizeCounter.set(patternSize_index, GUIPatternSizeCounter.get(patternSize_index) + 1);
					// System.out.println("bestPattern");
					// for(int i=0; i<bestPattern.size(); i++)
					// bestPattern.get(i).print();

					// 8. update weights of edge label and clusters based on best pattern selected
					PM_updateWeights(bestPattern, distinctCandidatePatterns_closureIndex.get(bestPatternIndex));
				} else
					g = GUISize;
			}
		}
		Long generatePatternEndTime = System.currentTimeMillis();
		System.out.println(
				"finish generating pattern: time duration(ms)=" + (generatePatternEndTime - generatePatternStartTime));

		// process database-END
		String pathToSaveImage = PM_resetThumbnailFolder();
		PM_generateThumbnails(pathToSaveImage, GUIPatterns, dbName);
		PM_loadThumbnails(pathToSaveImage);

		PM_savePatternsToFile(pathToSaveImage, GUIPatterns);
		System.out.println("finish generating pattern");
	}
	

	public void generatePatterns() throws IOException {

		// *********************** Generate GUIPatterns *******************************
		System.out.println("*********************** Generate GUIPatterns *******************************");
		ArrayList<ArrayList<Integer>> original_clusterIDList = new ArrayList<ArrayList<Integer>>();// graph ids in
																									// clusters
		System.out.println("start generating pattern");
		Long generatePatternStartTime = System.currentTimeMillis();
		{
			// 1. read the cluster.txt file first
			System.out.println("STEP 1: reading cluster file");
			fullyContainedGraphID = new ArrayList<Integer>();
			/// read clusters into original_clusterIDList, and stores all graphid into
			/// fullyContainedGraphID
			original_clusterIDList = readClusterFile(InitialClusterName);
			String filename = DataBaseName;
			int totalGraphs = PM_generateClusterClosure(filename, original_clusterIDList);
			for (int i = 0; i < original_clusterIDList.size(); i++)
				c_wt.add((float) original_clusterIDList.get(i).size() / (float) maxClosureSize);
			System.out.println("totalGraphs [here]=" + totalGraphs);
			for (int i = 0; i < DBEdgeLabel.size(); i++)
				DBEdge_wt.add((float) DBEdgeLabelFreq.get(i) / (float) totalGraphs);
			System.out.println("DBEdgeLabelFreq=" + DBEdgeLabelFreq.toString());
			System.out.println("DBEdge_wt=" + DBEdge_wt.toString());

			ArrayList<Integer> GUIPatternSizeCounter = new ArrayList<Integer>();
			ArrayList<Integer> GUIPatternSize = new ArrayList<Integer>();
			// for(int i=patternSetInfo.getPatternSizeMin();
			// i<=patternSetInfo.getPatternSizeMax(); i++)
			for (int i = minCannedPatternSize; i <= maxCannedPatternSize; i++) {
				GUIPatternSize.add(i);
				GUIPatternSizeCounter.add(0);
			}
			boolean PRINT = false;
			for (int g = 0; g < GUISize; g++) {
				System.out.println("------------------Mining pattern " + (g + 1) + " -----------------------");
				// 3. find first clusters to start with
				// choose candidate clusters containing most freq edge not covered yet
				System.out.println("STEP 3: finding candidate closure");
				Float bestEdgeWt = Collections.max(DBEdge_wt);
				int bestEdgeIndex = DBEdge_wt.indexOf(bestEdgeWt);
				String mostFreqEdge = DBEdgeLabel.get(bestEdgeIndex);
				System.out.println("DBEdgeLabel: " + DBEdgeLabel.toString());
				System.out.println("DBEdge_wt: " + DBEdge_wt.toString());
				System.out.println("mostFreqEdge: " + mostFreqEdge + " bestEdgeWt: " + bestEdgeWt);
				// if(true) return ;
				Long startTime = System.currentTimeMillis();
				ArrayList<Integer> candidateClosureIndex = PM_getCandidateClosureIndex(mostFreqEdge, 1);// no
																										// threading
																										// here
				Long endTime = System.currentTimeMillis();
				System.out.println("get candidate closure index time: " + (endTime - startTime) + " ms");
				System.out.println("candidateClosureIndex: [" + candidateClosureIndex.size() + "] "
						+ candidateClosureIndex.toString());

				// 4. for each candidate cluster, find the best patterns
				// PM_findBestPatternOfClosure(candidateClosureIndex,
				// patternSetInfo.getPatternSizeMin(), patternSetInfo.getPatternSizeMax(),
				// GUIPatternSize, GUIPatternSizeCounter, GUISize, databaseInfo);
				PM_findBestPatternOfClosure(candidateClosureIndex, minCannedPatternSize, maxCannedPatternSize,
						GUIPatternSize, GUIPatternSizeCounter, GUISize);

				if (candidatePatterns.size() > 0) {
					// 5. collapse candidatePatterns to distinct ones
					PRINT = true;

					//////// Remove duplicated patterns , input is candidatePatterns, output is
					//////// distinctCandidatePatterns

					// PM_collapseCandidatePatterns(candidatePatterns,
					// candidatePatterns_closureIndex,
					// patternSetInfo.getPatternSizeMax()-patternSetInfo.getPatternSizeMax()+1,
					// PRINT);
					PM_collapseCandidatePatterns(candidatePatterns, candidatePatterns_closureIndex,
							maxCannedPatternSize - minCannedPatternSize + 1, PRINT);

					System.out.println("***************START*********************");
					System.out.println("size1:" + candidatePatterns.size());
					for (int k = 0; k < candidatePatterns.size(); k++) {
						for (int k2 = 0; k2 < candidatePatterns.get(k).size(); k2++) {
							candidatePatterns.get(k).get(k2).print();
						}
						System.out.println();
					}
					System.out.println();
					System.out.println("size2:" + candidatePatterns_closureIndex.size());
					for (int k = 0; k < candidatePatterns_closureIndex.size(); k++) {
						System.out.print(candidatePatterns_closureIndex.get(k) + ";");
					}
					System.out.println();

					System.out.println("Kai3:" + distinctCandidatePatterns.size() + "Kai4:"
							+ distinctCandidatePatterns_closureIndex.size());
					ArrayList<ArrayList<closureEdge>> temp_distinctCandidatePatterns = new ArrayList<ArrayList<closureEdge>>();
					ArrayList<ArrayList<Integer>> temp_distinctCandidatePatterns_closureIndex = new ArrayList<ArrayList<Integer>>();

					for (int k = 0; k < distinctCandidatePatterns.size(); k++) {
						if (distinctCandidatePatterns.get(k) != null
								&& k < distinctCandidatePatterns_closureIndex.size()
								&& distinctCandidatePatterns_closureIndex.get(k) != null) {
							temp_distinctCandidatePatterns.add(distinctCandidatePatterns.get(k));
							temp_distinctCandidatePatterns_closureIndex
									.add(distinctCandidatePatterns_closureIndex.get(k));
						}
					}
					distinctCandidatePatterns.clear();
					distinctCandidatePatterns = temp_distinctCandidatePatterns;
					distinctCandidatePatterns_closureIndex.clear();
					distinctCandidatePatterns_closureIndex = temp_distinctCandidatePatterns_closureIndex;

					System.out.println("Kai5:" + distinctCandidatePatterns.size() + "Kai6:"
							+ distinctCandidatePatterns_closureIndex.size());

					/*
					 * System.out.println("size3:"+distinctCandidatePatterns.size());
					 * ArrayList<ArrayList<closureEdge>> temp_distinctCandidatePatterns = new
					 * ArrayList<ArrayList<closureEdge>>(); for(int
					 * k=0;k<distinctCandidatePatterns.size();k++) {
					 * if(distinctCandidatePatterns.get(k) != null) {
					 * temp_distinctCandidatePatterns.add(distinctCandidatePatterns.get(k)); } }
					 * distinctCandidatePatterns.clear(); distinctCandidatePatterns =
					 * temp_distinctCandidatePatterns;
					 * 
					 * System.out.println();
					 * System.out.println("size4:"+distinctCandidatePatterns_closureIndex.size());
					 * ArrayList<ArrayList<Integer>> temp_distinctCandidatePatterns_closureIndex =
					 * new ArrayList<ArrayList<Integer>>(); for(int
					 * k=0;k<distinctCandidatePatterns_closureIndex.size();k++) {
					 * if(distinctCandidatePatterns_closureIndex.get(k) != null)
					 * temp_distinctCandidatePatterns_closureIndex.add(
					 * distinctCandidatePatterns_closureIndex.get(k) ); }
					 * distinctCandidatePatterns_closureIndex.clear();
					 * distinctCandidatePatterns_closureIndex =
					 * temp_distinctCandidatePatterns_closureIndex; System.out.println();
					 * 
					 * System.out.println("Kai5:"+distinctCandidatePatterns.size()+
					 * "Kai6:"+distinctCandidatePatterns_closureIndex.size());
					 */
					System.out.println("***************END*********************");

					// System.out.println("*****PM_computePatternScore1*****");
					// 6. compute score of distinct candidate patterns:
					// patternScore=clusterWt*(1+GED)
					PM_computePatternScore(distinctCandidatePatterns, GUIPatterns, GUISize, GUIPatternSize.size());
					// System.out.println("*****PM_computePatternScore2*****");
					// 7. find best pattern based on score (highest patternScore)
					// System.out.println("dPattern wt (cluster only):
					// <"+distinctCandidatePatterns_score.size()+">
					// "+distinctCandidatePatterns_score.toString());
					// WriteFile wf=new WriteFile();
					// wf.writeToFile(distinctCandidatePatterns_score);
					int count = 0;
					while (count < distinctCandidatePatterns_score.size()) {
						if (distinctCandidatePatterns_score.get(count) == null) {
							distinctCandidatePatterns_score.remove(count);
							distinctCandidatePatterns.remove(count);
						} else
							count++;
					}
					double bestScore = Collections.max(distinctCandidatePatterns_score);
					int bestPatternIndex = distinctCandidatePatterns_score.indexOf(bestScore);
					System.out.println("bestPatternIndex: " + bestPatternIndex);
					ArrayList<closureEdge> bestPattern = distinctCandidatePatterns.get(bestPatternIndex);
					/////// All patterns are stored in GUIPatterns //////////////////////////
					GUIPatterns.add(bestPattern);
					int bestPatternSize = bestPattern.size();
					// update GUIPatternSizeCounter
					int patternSize_index = GUIPatternSize.indexOf(bestPatternSize);
					if (patternSize_index != -1)
						GUIPatternSizeCounter.set(patternSize_index, GUIPatternSizeCounter.get(patternSize_index) + 1);
					// System.out.println("bestPattern");
					// for(int i=0; i<bestPattern.size(); i++)
					// bestPattern.get(i).print();

					// 8. update weights of edge label and clusters based on best pattern selected
					PM_updateWeights(bestPattern, distinctCandidatePatterns_closureIndex.get(bestPatternIndex));
				} else
					g = GUISize;
			}
		}
		Long generatePatternEndTime = System.currentTimeMillis();
		System.out.println(
				"finish generating pattern: time duration(ms)=" + (generatePatternEndTime - generatePatternStartTime));

		// process database-END
		String pathToSaveImage = PM_resetThumbnailFolder();
		PM_generateThumbnails(pathToSaveImage, GUIPatterns, dbName);
		PM_loadThumbnails(pathToSaveImage);

		PM_savePatternsToFile(pathToSaveImage, GUIPatterns);
		System.out.println("finish generating pattern");
	}

	private ArrayList<Integer> PM_getCandidateClosureIndex(String mostFreqEdge, int count) {
		ArrayList<Integer> candidateClosureIndex = new ArrayList<Integer>();
		for (int i = 0; i < closureGraphList.size(); i++) {
			JGraphtClosureGraph cGraph = closureGraphList.get(i);
			if (cGraph.getEdgeLabelList().contains(mostFreqEdge) == true) {
				for (int c = 0; c < count; c++)
					candidateClosureIndex.add(closureGraphIndexList.get(i));
			}
		}
		return candidateClosureIndex;
	}

	private ArrayList<Integer> PM_getCandidateClosureIndex2(String mostFreqEdge, int count) {
		ArrayList<Integer> candidateClosureIndex = new ArrayList<Integer>();
		for (int i = 0; i < closureGraphList2.size(); i++) {
			JGraphtClosureGraph cGraph = closureGraphList2.get(i);
			if (cGraph.getEdgeLabelList().contains(mostFreqEdge) == true) {
				for (int c = 0; c < count; c++)
					candidateClosureIndex.add(closureGraphIndexList2.get(i));
			}
		}
		return candidateClosureIndex;
	}

	private ArrayList<ArrayList<Integer>> getPatternIndexForEachThread(int numSize, ArrayList<Integer> list) {
		ArrayList<ArrayList<Integer>> thread_listIndex = new ArrayList<ArrayList<Integer>>();

		for (int i = 0; i < numSize; i++) {
			ArrayList<Integer> thisThread_listIndex = new ArrayList<Integer>();
			for (int j = 0 + i; j < list.size(); j = j + numSize)
				thisThread_listIndex.add(j);
			thread_listIndex.add(thisThread_listIndex);
		}

		return thread_listIndex;
	}

	private void PM_collapseCandidatePatterns(ArrayList<ArrayList<closureEdge>> candidatePatterns,
			ArrayList<Integer> candidateClosureIndex, int numOfSizes, boolean PRINT) {
		// for each pattern size, we can assign to a thread.
		// if more pattern sizes than threads, then a thread will be assigned one or
		// more sizes.
		// ---------------------------------------------------------------------------
		// candidatePatterns is arranged in such as a way now:
		// [e.g., 3 patterns sizes and 10 closures]: candidatePatterns=P1 P2 P3 P4 P5 P6
		// P7 P8 P9 P10 ...PN where
		// P1 P2 P3 belongs to closure1, P4 P5 P6 belongs to closure2, P7 P8 P9 belongs
		// to closure3 etc.
		// P1=size1, P2=size2, P3=size3
		// P4=size1, P5=size2, P6=size3
		// P7=size1, P8=size2, P9=size3 etc.
		System.out.println("STEP 5: collapsing candidate patterns");
		Long startTime = System.currentTimeMillis();
		// divide load into np-threads
		int np = Runtime.getRuntime().availableProcessors();
		ArrayList<ArrayList<Integer>> thread_patternIndex = getPatternIndexForEachThread(numOfSizes,
				candidateClosureIndex);
		ArrayList<Thread> threadList = new ArrayList<Thread>();
		ArrayList<String> threadNameList = new ArrayList<String>();
		// System.out.println("*************Here0000000*****************");
		CollapsePatternThreadCompleteListener threadListener = new CollapsePatternThreadCompleteListener(
				thread_patternIndex, candidatePatterns, candidateClosureIndex, threadList, threadNameList);
		// System.out.println("*************Here1111111*****************");
		int count = 0;
		while (thread_patternIndex.size() > 0) {
			System.out.println("1111:" + thread_patternIndex.size());
			if (np > threadList.size()) {
				ArrayList<ArrayList<closureEdge>> thisThread_candidatePattern = new ArrayList<ArrayList<closureEdge>>();
				ArrayList<Integer> thisThread_candidateClosureIndex = new ArrayList<Integer>();
				ArrayList<Integer> thisThread_patternIndex = thread_patternIndex.get(0);
				for (int j = 0; j < thisThread_patternIndex.size(); j++) {
					if (candidatePatterns.size() > thisThread_patternIndex.get(j)) {
						thisThread_candidatePattern.add(candidatePatterns.get(thisThread_patternIndex.get(j)));
						thisThread_candidateClosureIndex.add(candidateClosureIndex.get(thisThread_patternIndex.get(j)));
					}
				}
				// System.out.println("*************ffffff1111111*****************");
				CollapsePatternThread t = new CollapsePatternThread(thisThread_candidatePattern,
						thisThread_candidateClosureIndex, count++, threadListener);
				// System.out.println("*************ffffff222222*****************");
				Thread gpThread = new Thread(t);
				gpThread.start();
				threadNameList.add(t.getName());
				threadList.add(gpThread);
				if (thread_patternIndex.size() > 0)
					thread_patternIndex.remove(0);
				// System.out.println("*************ffffff333333*****************");
			}
			// System.out.println("222222:"+thread_patternIndex.size() );
		}
		// System.out.println("*************Here333333333*****************");
		for (int i = 0; i < threadList.size(); i++) {
			try {
				threadList.get(i).join();
			} catch (InterruptedException ex) {
				// Exceptions.printStackTrace(ex);
			}
		}
		boolean SOME_THREAD_STILL_ALIVE = false;
		for (int i = 0; i < threadList.size(); i++) {
			if (threadList.get(i).isAlive()) {
				SOME_THREAD_STILL_ALIVE = true;
				i = threadList.size();
			}
		}
		while (SOME_THREAD_STILL_ALIVE) {
			try {
				Thread.sleep(10);
				for (int i = 0; i < threadList.size(); i++) {
					if (threadList.get(i).isAlive()) {
						SOME_THREAD_STILL_ALIVE = true;
						i = threadList.size();
					}
				}
			} catch (InterruptedException ex) {
				// Exceptions.printStackTrace(ex);
			}
		}
		// System.out.println("all Collapse threads are DEAD!!! can proceed");
		// System.out.println("*************Here22222*****************");
		if (threadListener.getDistinctPatterns() != null)
			distinctCandidatePatterns = threadListener.getDistinctPatterns();
		if (threadListener.getDistinctPatternsClosureIndex() != null)
			distinctCandidatePatterns_closureIndex = threadListener.getDistinctPatternsClosureIndex();
		System.out.println("distinctCandidatePatternsTotal:" + distinctCandidatePatterns.size()
				+ " distinctCandidatePatterns_closureIndexTotal:" + distinctCandidatePatterns_closureIndex.size());
		Long endTime = System.currentTimeMillis();
		System.out.println("collapse candidate pattern time: " + (endTime - startTime) + " ms");
		PRINT = false;
		if (PRINT) {
			System.out.println("******************** collapsing candidate patterns!! ");
			for (int i = 0; i < distinctCandidatePatterns.size(); i++) {
				System.out.println("Distinct pattern " + i + " ======= closure index: "
						+ distinctCandidatePatterns_closureIndex.get(i).toString());
				ArrayList<closureEdge> d = distinctCandidatePatterns.get(i);
				for (int j = 0; j < d.size(); j++)
					d.get(j).print();
			}
		}
	}

	private void PM_collapseCandidatePatterns2(ArrayList<ArrayList<closureEdge>> candidatePatterns,
			ArrayList<Integer> candidateClosureIndex, int numOfSizes, boolean PRINT) {
		// for each pattern size, we can assign to a thread.
		// if more pattern sizes than threads, then a thread will be assigned one or
		// more sizes.
		// ---------------------------------------------------------------------------
		// candidatePatterns is arranged in such as a way now:
		// [e.g., 3 patterns sizes and 10 closures]: candidatePatterns=P1 P2 P3 P4 P5 P6
		// P7 P8 P9 P10 ...PN where
		// P1 P2 P3 belongs to closure1, P4 P5 P6 belongs to closure2, P7 P8 P9 belongs
		// to closure3 etc.
		// P1=size1, P2=size2, P3=size3
		// P4=size1, P5=size2, P6=size3
		// P7=size1, P8=size2, P9=size3 etc.
		System.out.println("STEP 5: collapsing candidate patterns");
		Long startTime = System.currentTimeMillis();
		// divide load into np-threads
		int np = Runtime.getRuntime().availableProcessors();
		ArrayList<ArrayList<Integer>> thread_patternIndex = getPatternIndexForEachThread(numOfSizes,
				candidateClosureIndex);
		ArrayList<Thread> threadList = new ArrayList<Thread>();
		ArrayList<String> threadNameList = new ArrayList<String>();
		CollapsePatternThreadCompleteListener threadListener = new CollapsePatternThreadCompleteListener(
				thread_patternIndex, candidatePatterns, candidateClosureIndex, threadList, threadNameList);
		// System.out.println("**************111111111111111********************");
		int count = 0;
		while (thread_patternIndex.size() > 0) {
			System.out.println("1111:" + thread_patternIndex.size());
			if (np > threadList.size()) {
				ArrayList<ArrayList<closureEdge>> thisThread_candidatePattern = new ArrayList<ArrayList<closureEdge>>();
				ArrayList<Integer> thisThread_candidateClosureIndex = new ArrayList<Integer>();
				ArrayList<Integer> thisThread_patternIndex = thread_patternIndex.get(0);
				for (int j = 0; j < thisThread_patternIndex.size(); j++) {
					if (candidatePatterns.size() > thisThread_patternIndex.get(j)) {
						thisThread_candidatePattern.add(candidatePatterns.get(thisThread_patternIndex.get(j)));
						thisThread_candidateClosureIndex.add(candidateClosureIndex.get(thisThread_patternIndex.get(j)));
					}
				}
				CollapsePatternThread t = new CollapsePatternThread(thisThread_candidatePattern,
						thisThread_candidateClosureIndex, count++, threadListener);
				Thread gpThread = new Thread(t);
				gpThread.start();
				threadNameList.add(t.getName());
				threadList.add(gpThread);
				if(thread_patternIndex.size()>0)
				thread_patternIndex.remove(0);
			}
		}
		// System.out.println("**************22222222222222********************");
		for (int i = 0; i < threadList.size(); i++) {
			try {
				threadList.get(i).join();
			} catch (InterruptedException ex) {
				// Exceptions.printStackTrace(ex);
			}
		}
		boolean SOME_THREAD_STILL_ALIVE = false;
		for (int i = 0; i < threadList.size(); i++) {
			if (threadList.get(i).isAlive()) {
				SOME_THREAD_STILL_ALIVE = true;
				i = threadList.size();
			}
		}
		while (SOME_THREAD_STILL_ALIVE) {
			try {
				Thread.sleep(10);
				for (int i = 0; i < threadList.size(); i++) {
					if (threadList.get(i).isAlive()) {
						SOME_THREAD_STILL_ALIVE = true;
						i = threadList.size();
					}
				}
			} catch (InterruptedException ex) {
				// Exceptions.printStackTrace(ex);
			}
		}
		// System.out.println("all Collapse threads are DEAD!!! can proceed");
		// System.out.println("**************333333333333333333********************");

		distinctCandidatePatterns2 = threadListener.getDistinctPatterns();
		distinctCandidatePatterns_closureIndex2 = threadListener.getDistinctPatternsClosureIndex();
		System.out.println("distinctCandidatePatternsPM_collapseCandidatePatterns2:" + distinctCandidatePatterns2.size()
				+ " distinctCandidatePatterns_closureIndexPM_collapseCandidatePatterns2:"
				+ distinctCandidatePatterns_closureIndex2.size());
		Long endTime = System.currentTimeMillis();
		System.out.println("collapse candidate pattern time: " + (endTime - startTime) + " ms");
		PRINT = false;
		if (PRINT) {
			System.out.println("******************** collapsing candidate patterns!! ");
			for (int i = 0; i < distinctCandidatePatterns2.size(); i++) {
				System.out.println("Distinct pattern " + i + " ======= closure index: "
						+ distinctCandidatePatterns_closureIndex2.get(i).toString());
				ArrayList<closureEdge> d = distinctCandidatePatterns2.get(i);
				for (int j = 0; j < d.size(); j++)
					d.get(j).print();
			}
		}
	}

	private ArrayList<ArrayList<Integer>> PM_getCandidatePatternIndexForEachThread(int numThreads, int numPatterns) {
		// System.out.println("indexList: ["+indexList.size()+"]
		// "+indexList.toString());
		ArrayList<ArrayList<Integer>> thread_indexList = new ArrayList<ArrayList<Integer>>();
		int numBucketsWithExtras = numPatterns % numThreads;
		int defaultSize = (numPatterns - numBucketsWithExtras) / numThreads;
		int size;
		int count = 0;
		for (int i = 0; i < numThreads; i++) {
			if (i < numBucketsWithExtras)
				size = defaultSize + 1;
			else
				size = defaultSize;
			ArrayList<Integer> thisThread_indexList = new ArrayList<Integer>();
			for (int j = 0; j < size; j++)
				thisThread_indexList.add(count + j);
			/*
			 * if(size>80) //fix each thread as 80 patterns { int numIndexToRemove=size-80;
			 * int counter=0; while(counter<numIndexToRemove) { Random rand=new Random();
			 * int indexToRemove=rand.nextInt(thisThread_indexList.size());
			 * thisThread_indexList.remove(indexToRemove); counter++; } }
			 */
			thread_indexList.add(thisThread_indexList);
			count = count + size;
		}
		// UNCOMMENT for debugging
		/*
		 * System.out.println("PM_getCandidatePatternIndexForEachThread count "+count);
		 * for(int i=0; i<thread_indexList.size(); i++) { ArrayList<Integer>
		 * iList=thread_indexList.get(i); System.out.println("Thread "+i+": "); for(int
		 * j=0; j<iList.size(); j++) System.out.print(iList.get(j)+" "); }
		 */
		return thread_indexList;
	}

	private void PM_computePatternScore(ArrayList<ArrayList<closureEdge>> patternList,
			ArrayList<ArrayList<closureEdge>> GUIPatterns, int GUISize, int binNum) {
		System.out.println("STEP 6a: compute pattern score for candidate patterns");
		Long startTime = System.currentTimeMillis();
		int np = Runtime.getRuntime().availableProcessors() - 2;
		// int np=1;
		System.out.println("PM_findBestPatternOfClosure numProcessors available=" + np);
		// divide load into np-threads
		ArrayList<Thread> score_threadList = new ArrayList<Thread>();
		ComputeScoreThreadCompleteListener threadListener = new ComputeScoreThreadCompleteListener();
		ArrayList<ArrayList<Integer>> thread_candidatePatternIndex = PM_getCandidatePatternIndexForEachThread(np,
				patternList.size());

		for (int i = 0; i < np; i++) {
			ComputeScoreThread t = new ComputeScoreThread(thread_candidatePatternIndex.get(i),
					distinctCandidatePatterns, distinctCandidatePatterns_closureIndex, GUIPatterns, c_wt, i,
					threadListener, GUISize, binNum);

			Thread pThread = new Thread(t, t.getName());
			pThread.start();
			score_threadList.add(pThread);
		}
		try {
			for (int i = 0; i < np; i++) {
				// System.out.println(score_threadList.get(i).getName()+" joins");
				score_threadList.get(i).join();
			}
		} catch (InterruptedException ex) {
			// Exceptions.printStackTrace(ex);
		}

		boolean SOME_THREAD_STILL_ALIVE = false;
		for (int i = 0; i < score_threadList.size(); i++) {
			if (score_threadList.get(i).isAlive()) {
				SOME_THREAD_STILL_ALIVE = true;
				i = score_threadList.size();
			}
		}
		while (SOME_THREAD_STILL_ALIVE) {
			try {
				Thread.sleep(10);
				for (int i = 0; i < score_threadList.size(); i++) {
					if (score_threadList.get(i).isAlive()) {
						SOME_THREAD_STILL_ALIVE = true;
						i = score_threadList.size();
					}
				}
			} catch (InterruptedException ex) {
				// Exceptions.printStackTrace(ex);
			}
		}
		System.out.println("all score threads are DEAD!!! can proceed");

		System.out.println("candidatePatterns: " + candidatePatterns.size());
		Long endTime = System.currentTimeMillis();
		System.out.println("compute score time: " + (endTime - startTime) + " ms");
		// Long stopTime=System.currentTimeMillis();
		// System.out.println("time taken:"+ (stopTime-startTime)+" ms");
		// System.out.println("candidatePatterns: "+candidatePatterns.size());
		// for(int i=0; i<=15; i++)
		// {
		// ArrayList<closureEdge> p=candidatePatterns.get(i);
		// System.out.println("pattern "+i);
		// for(int j=0; j<p.size(); j++)
		// p.get(j).print();
		// }

		distinctCandidatePatterns = threadListener.getCandidatePatterns();
		distinctCandidatePatterns_score = threadListener.getCandidatePatternScore();
		// System.out.println("distinctCandidatePatterns_score:
		// "+distinctCandidatePatterns_score.toString());
		distinctCandidatePatterns_closureIndex = threadListener.getCandidatePatternClosureIndex();
	}

	private void PM_computePatternScore2(ArrayList<ArrayList<closureEdge>> patternList,
			ArrayList<ArrayList<closureEdge>> GUIPatterns, int GUISize, int binNum) {
		System.out.println("STEP 6a: compute pattern score for candidate patterns");
		Long startTime = System.currentTimeMillis();
		int np = Runtime.getRuntime().availableProcessors() - 2;
		// int np=1;
		System.out.println("PM_findBestPatternOfClosure numProcessors available=" + np);
		// divide load into np-threads
		ArrayList<Thread> score_threadList = new ArrayList<Thread>();
		ComputeScoreThreadCompleteListener threadListener = new ComputeScoreThreadCompleteListener();
		ArrayList<ArrayList<Integer>> thread_candidatePatternIndex = PM_getCandidatePatternIndexForEachThread(np,
				patternList.size());

		for (int i = 0; i < np; i++) {
			ComputeScoreThread t = new ComputeScoreThread(thread_candidatePatternIndex.get(i),
					distinctCandidatePatterns2, distinctCandidatePatterns_closureIndex2, GUIPatterns, c_wt2, i,
					threadListener, GUISize, binNum);

			Thread pThread = new Thread(t, t.getName());
			pThread.start();
			score_threadList.add(pThread);
		}
		try {
			for (int i = 0; i < np; i++) {
				// System.out.println(score_threadList.get(i).getName()+" joins");
				score_threadList.get(i).join();
			}
		} catch (InterruptedException ex) {
			// Exceptions.printStackTrace(ex);
		}

		boolean SOME_THREAD_STILL_ALIVE = false;
		for (int i = 0; i < score_threadList.size(); i++) {
			if (score_threadList.get(i).isAlive()) {
				SOME_THREAD_STILL_ALIVE = true;
				i = score_threadList.size();
			}
		}
		while (SOME_THREAD_STILL_ALIVE) {
			try {
				Thread.sleep(10);
				for (int i = 0; i < score_threadList.size(); i++) {
					if (score_threadList.get(i).isAlive()) {
						SOME_THREAD_STILL_ALIVE = true;
						i = score_threadList.size();
					}
				}
			} catch (InterruptedException ex) {
				// Exceptions.printStackTrace(ex);
			}
		}
		System.out.println("all score threads are DEAD!!! can proceed");

		System.out.println("candidatePatterns: " + candidatePatterns2.size());
		Long endTime = System.currentTimeMillis();
		System.out.println("compute score time: " + (endTime - startTime) + " ms");
		// Long stopTime=System.currentTimeMillis();
		// System.out.println("time taken:"+ (stopTime-startTime)+" ms");
		// System.out.println("candidatePatterns: "+candidatePatterns.size());
		// for(int i=0; i<=15; i++)
		// {
		// ArrayList<closureEdge> p=candidatePatterns.get(i);
		// System.out.println("pattern "+i);
		// for(int j=0; j<p.size(); j++)
		// p.get(j).print();
		// }

		distinctCandidatePatterns2 = threadListener.getCandidatePatterns();
		distinctCandidatePatterns_score2 = threadListener.getCandidatePatternScore();
		// System.out.println("distinctCandidatePatterns_score:
		// "+distinctCandidatePatterns_score.toString());
		distinctCandidatePatterns_closureIndex2 = threadListener.getCandidatePatternClosureIndex();
	}
	
	private void PM_computePatternScore2_Update(ArrayList<ArrayList<closureEdge>> patternList,
			ArrayList<ArrayList<closureEdge>> GUIPatterns, int GUISize, int binNum, Trie trietree) {
		System.out.println("STEP 6a: compute pattern score for candidate patterns");
		Long startTime = System.currentTimeMillis();
		int np = Runtime.getRuntime().availableProcessors() - 2;
		// int np=1;
		System.out.println("PM_findBestPatternOfClosure numProcessors available=" + np);
		// divide load into np-threads
		ArrayList<Thread> score_threadList = new ArrayList<Thread>();
		ComputeScoreThreadCompleteListenerUpdated threadListener = new ComputeScoreThreadCompleteListenerUpdated();
		ArrayList<ArrayList<Integer>> thread_candidatePatternIndex = PM_getCandidatePatternIndexForEachThread(np,
				patternList.size());

		for (int i = 0; i < np; i++) {
			ComputeScoreThreadUpdated t = new ComputeScoreThreadUpdated(thread_candidatePatternIndex.get(i),
					distinctCandidatePatterns2, distinctCandidatePatterns_closureIndex2, GUIPatterns, c_wt2, i,
					threadListener, GUISize, binNum,  trietree);

			Thread pThread = new Thread(t, t.getName());
			pThread.start();
			score_threadList.add(pThread);
		}
		try {
			for (int i = 0; i < np; i++) {
				// System.out.println(score_threadList.get(i).getName()+" joins");
				score_threadList.get(i).join();
			}
		} catch (InterruptedException ex) {
			// Exceptions.printStackTrace(ex);
		}

		boolean SOME_THREAD_STILL_ALIVE = false;
		for (int i = 0; i < score_threadList.size(); i++) {
			if (score_threadList.get(i).isAlive()) {
				SOME_THREAD_STILL_ALIVE = true;
				i = score_threadList.size();
			}
		}
		while (SOME_THREAD_STILL_ALIVE) {
			try {
				Thread.sleep(10);
				for (int i = 0; i < score_threadList.size(); i++) {
					if (score_threadList.get(i).isAlive()) {
						SOME_THREAD_STILL_ALIVE = true;
						i = score_threadList.size();
					}
				}
			} catch (InterruptedException ex) {
				// Exceptions.printStackTrace(ex);
			}
		}
		System.out.println("all score threads are DEAD!!! can proceed");

		System.out.println("candidatePatterns: " + candidatePatterns2.size());
		Long endTime = System.currentTimeMillis();
		System.out.println("compute score time: " + (endTime - startTime) + " ms");
		// Long stopTime=System.currentTimeMillis();
		// System.out.println("time taken:"+ (stopTime-startTime)+" ms");
		// System.out.println("candidatePatterns: "+candidatePatterns.size());
		// for(int i=0; i<=15; i++)
		// {
		// ArrayList<closureEdge> p=candidatePatterns.get(i);
		// System.out.println("pattern "+i);
		// for(int j=0; j<p.size(); j++)
		// p.get(j).print();
		// }

		distinctCandidatePatterns2 = threadListener.getCandidatePatterns();
		distinctCandidatePatterns_score2 = threadListener.getCandidatePatternScore();
		// System.out.println("distinctCandidatePatterns_score:
		// "+distinctCandidatePatterns_score.toString());
		distinctCandidatePatterns_closureIndex2 = threadListener.getCandidatePatternClosureIndex();
	}

	private void PM_savePatternsToFile(String folderPath, ArrayList<ArrayList<closureEdge>> GUIPattern)
			throws IOException {
		String outputFilename = folderPath + "\\GUIPatterns.txt";

		try {
			BufferedWriter bufWriter = new BufferedWriter(new FileWriter(outputFilename));
			for (int i = 0; i < GUIPattern.size(); i++) {
				ArrayList<closureEdge> thisPattern = GUIPattern.get(i);
				ArrayList<closureVertex> thisPattern_vList = new ArrayList<closureVertex>();
				for (int j = 0; j < thisPattern.size(); j++) {
					closureEdge e = thisPattern.get(j);
					closureVertex s = e.getSource();
					closureVertex t = e.getTarget();
					if (thisPattern_vList.contains(s) == false)
						thisPattern_vList.add(s);
					if (thisPattern_vList.contains(t) == false)
						thisPattern_vList.add(t);
				}
				// write header
				bufWriter.write("t # " + i + " " + thisPattern_vList.size());
				bufWriter.newLine();
				// write vertices
				for (int j = 0; j < thisPattern_vList.size(); j++) {
					closureVertex v = thisPattern_vList.get(j);
					String v_label = v.getLabel().get(0);
					bufWriter.write("v " + j + " " + v_label);
					bufWriter.newLine();
				}
				// write edges
				for (int j = 0; j < thisPattern.size(); j++) {
					closureEdge e = thisPattern.get(j);
					closureVertex s = e.getSource();
					closureVertex t = e.getTarget();
					int s_index = thisPattern_vList.indexOf(s);
					int t_index = thisPattern_vList.indexOf(t);
					if (s_index < t_index)
						bufWriter.write("e " + s_index + " " + t_index + " 0");
					else
						bufWriter.write("e " + t_index + " " + s_index + " 0");
					bufWriter.newLine();
				}
				bufWriter.newLine();
			}

			System.out.println("all done!");
			bufWriter.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
	}

	private ArrayList<ArrayList<Object>> loadImagesFromFolder(String _freqFolderPath) {

		File file = new File(_freqFolderPath);
		File[] fileList = file.listFiles();
		ArrayList<ArrayList<Object>> imageArray = new ArrayList<ArrayList<Object>>();
		int numOfCol = 2;
		int numOfRow = Math.floorDiv(fileList.length + 1, numOfCol);

		for (int i = 0; i < numOfRow; i++) {
			ArrayList<Object> rowElement = new ArrayList<Object>();
			for (int j = 0; j < numOfCol; j++) {

				// int iconIndex = i * numPerRow + j;
				int imageIndex = i * numOfCol + j;
				if (imageIndex < fileList.length) {
					String idStr = fileList[imageIndex].getName().substring(0,
							fileList[imageIndex].getName().length() - 4);
					int patId = Integer.parseInt(idStr);
					DnDImage tmpButton = new DnDImage(fileList[imageIndex].getAbsolutePath(), patId);
					//System.out.println("[loadImagesFromFolder] " + i + ", " + j + " file:"+ fileList[imageIndex].getAbsolutePath());
					rowElement.add(tmpButton);
				}
			}
			imageArray.add(rowElement);
		}
		return imageArray;
	}

	public void putUpPatterns(String _patternType, int columnSize, Object[][] data) {
		int Width = 150;
		Object[] columnNames = new Object[columnSize];
		for (int i = 0; i < columnNames.length; i++) {
			columnNames[i] = "";
		}

		ThumbnailTable table = new ThumbnailTable(columnNames, data, Width / columnSize);
		// patternPanel.remove(patternScrollPane);
		// patternScrollPane = new JScrollPane(table);
		// patternPanel.add(patternScrollPane, BorderLayout.CENTER);

		// patternPanel.revalidate();
	}

	private void PM_loadThumbnails(String imageFolderPath) {
		ArrayList<ArrayList<Object>> thumbnailTable = loadImagesFromFolder(imageFolderPath);
		int numOfRows = thumbnailTable.size();
		int numOfColumns = thumbnailTable.get(0).size();
		// System.out.println("PM_loadThumbnails numOfRows:"+numOfRows+"
		// numOfColumns:"+numOfColumns);
		Object[][] thumbnailTableObj = new Object[numOfRows][numOfColumns];
		for (int i = 0; i < thumbnailTable.size(); i++) {
			for (int j = 0; j < thumbnailTable.get(i).size(); j++) {
				thumbnailTableObj[i][j] = thumbnailTable.get(i).get(j);
			}
		}

		putUpPatterns("thumbnail", numOfColumns, thumbnailTableObj);
		System.out.println("PM_loadThumbnails => Pattern images loaded!");
	}

	private void PM_generateThumbnails(String pathToSaveImage, ArrayList<ArrayList<closureEdge>> GUIPatterns,
			String database) throws IOException {
		int patternId = 0;
		for (int x = 0; x < GUIPatterns.size(); x++) {
			Graph tmpPattern = new Graph();

			ArrayList<closureEdge> p = GUIPatterns.get(x);
			//System.out.println("GUI Pattern " + x);
			for (int i = 0; i < p.size(); i++)
				p.get(i).print();
			ArrayList<closureVertex> p_vList = new ArrayList<closureVertex>();
			int edgeNum = p.size();
			// preprocess to get distinct nodes
			for (int i = 0; i < edgeNum; i++) {
				closureEdge e = p.get(i);
				closureVertex s = e.getSource();
				closureVertex t = e.getTarget();
				if (p_vList.contains(s) == false)
					p_vList.add(s);
				if (p_vList.contains(t) == false)
					p_vList.add(t);
			}
			// Add nodes to temp pattern
			ArrayList<Integer> nodeIDLookUp = new ArrayList<Integer>();
			int vertexNum = p_vList.size();
			for (int i = 0; i < vertexNum; i++) {
				String nodeLabel = p_vList.get(i).getLabel().get(0);
				Vertex node = new Vertex();
				node.setLabel(nodeLabel);
				node.setID(i);
				nodeIDLookUp.add(p_vList.get(i).getID());
				// node.setID(p_vList.get(i).getID());

				tmpPattern.addNode(node);
			}
			// Add edges to temp pattern
			for (int i = 0; i < edgeNum; i++) {
				closureEdge e = p.get(i);
				closureVertex s = e.getSource();
				closureVertex t = e.getTarget();
				int s_ID = s.getID();
				int t_ID = t.getID();
				int e1 = nodeIDLookUp.indexOf(s_ID);
				int e2 = nodeIDLookUp.indexOf(t_ID);
				tmpPattern.addEdge(e1, e2);
				tmpPattern.getNode(e1).setIn(e2);
				tmpPattern.getNode(e2).setIn(e1);
				tmpPattern.getNode(e1).incDegree();
				tmpPattern.getNode(e2).incDegree();
				if (p_vList.contains(s) == false)
					p_vList.add(s);
				if (p_vList.contains(t) == false)
					p_vList.add(t);
			}

			// Set number of vertices and number of edges of the temp pattern
			tmpPattern.setVertexNum(vertexNum);
			tmpPattern.setEdgeNum(edgeNum);

			try {
				generatePatternImage(tmpPattern, patternId, pathToSaveImage, database);
			} catch (ClassNotFoundException ex) {
				// Exceptions.printStackTrace(ex);
			}
			patternId++;
		}
	}

	void generatePatternImage(Graph tmpPattern, int patternId, String imagePatternPath, String database)
			throws ClassNotFoundException, IOException {
       //  System.out.println("database: " + database);
		dotGenerator.createGraph(tmpPattern, database);
		dotGenerator.formatDotFile(patternId);

		// String cmdGeneratePNG = "cmd /c dot -Tpng -Kneato -Gepsilon=0.0001
		// patterns/temp_pattern.dot -o " + imagePatternPath +
		// Integer.toString(patternId) + ".png";
		String cmdGeneratePNG = "cmd /c dot -Tpng  -Kneato -Gepsilon=0.0001 patterns/temp_pattern.dot -o "
				+ imagePatternPath + Integer.toString(patternId) + ".png";
		// String cmdGeneratePNG = "cmd /c dot -Tpng -Kneato -Gepsilon=0.0001
		// patterns/temp_pattern.dot -o " + imagePatternPath +
		// Integer.toString(patternId) + ".png";
		// String cmdGenerateJPG = "cmd /c dot -Tjpg -Kneato -Gepsilon=0.0001
		// patterns/temp_pattern.dot -o " + imagePatternPath +
		// Integer.toString(patternId) + ".jpg";
		// String cmdGenerateSVG = "cmd /c dot -Tsvg -Kneato -Gepsilon=0.0001
		// patterns/temp_pattern.dot -o " + imagePatternPath +
		// Integer.toString(patternId) + ".svg";

		try {
			// System.out.println("generatePatternImage!!
			// imagePatternPath:"+imagePatternPath);
			//System.out.println("cmdGeneratePNG:" + cmdGeneratePNG);
			Process procPNG = Runtime.getRuntime().exec(cmdGeneratePNG);
			// Process procJPG = Runtime.getRuntime().exec(cmdGenerateJPG);
			// Process procSVG = Runtime.getRuntime().exec(cmdGenerateSVG);
			/*
			 * BufferedReader stdInput = new BufferedReader(new
			 * InputStreamReader(procPNG.getInputStream()));
			 * 
			 * Checking output of cmd running from java BufferedReader stdError = new
			 * BufferedReader(new InputStreamReader(procPNG.getErrorStream())); String s =
			 * ""; // read the output from the command
			 * System.out.println("Here is the standard output of the command:\n"); while
			 * ((s = stdInput.readLine()) != null) { System.out.println(s); }
			 * 
			 * // read any errors from the attempted command
			 * System.out.println("Here is the standard error of the command (if any):\n");
			 * while ((s = stdError.readLine()) != null) { System.out.println(s); }
			 */

			procPNG.waitFor();
			// procJPG.waitFor();
			// procSVG.waitFor();
			// Process procSVG = Runtime.getRuntime().exec(cmdGenerateSVG);
			// procSVG.waitFor();
		} catch (InterruptedException ex) {
			throw new RuntimeException(ex);
		}
	}

	private String PM_resetThumbnailFolder() throws IOException {
		String thumbnailFolderPath = "patterns\\thumbnails\\";
		// Create fresh ./patterns/image folder
		String cmdDeleteImageFolder = "cmd /c rmdir /Q /S " + thumbnailFolderPath;
		String cmdcmdMakeImageFolder = "cmd /c mkdir " + thumbnailFolderPath;
		try {
			Process procDeleteImageFolder = Runtime.getRuntime().exec(cmdDeleteImageFolder);
			procDeleteImageFolder.waitFor();
			Process procmdMakeImageFolder = Runtime.getRuntime().exec(cmdcmdMakeImageFolder);
			procmdMakeImageFolder.waitFor();
		} catch (InterruptedException ex) {
			throw new RuntimeException(ex);
		}
		return thumbnailFolderPath;
	}

	private String PM_resetThumbnailFolder2() throws IOException {
		String thumbnailFolderPath = "patterns\\thumbnails2\\";
		// Create fresh ./patterns/image folder
		String cmdDeleteImageFolder = "cmd /c rmdir /Q /S " + thumbnailFolderPath;
		String cmdcmdMakeImageFolder = "cmd /c mkdir " + thumbnailFolderPath;
		try {
			Process procDeleteImageFolder = Runtime.getRuntime().exec(cmdDeleteImageFolder);
			procDeleteImageFolder.waitFor();
			Process procmdMakeImageFolder = Runtime.getRuntime().exec(cmdcmdMakeImageFolder);
			procmdMakeImageFolder.waitFor();
		} catch (InterruptedException ex) {
			throw new RuntimeException(ex);
		}
		return thumbnailFolderPath;
	}

	private void PM_updateWeights(ArrayList<closureEdge> selectedPattern, ArrayList<Integer> pattern_clusterIndex) {
		Float n = 0.5f;
		// System.out.println("------------------------------------------------");
		// System.out.println("pattern_clusterIndex:"+pattern_clusterIndex.toString());
		// for(int i=0; i<selectedPattern.size(); i++)
		// selectedPattern.get(i).print();
		// System.out.println("------------------------------------------------");
		// System.out.println("updating weights");
		// System.out.println("BEFORE c_wt: "+c_wt.toString());
		// System.out.println("pattern_clusterIndex: "+pattern_clusterIndex.toString());
		// 1. update cluster weight by decrementing by factor of 1-n where n=0.5
		for (int i = 0; i < pattern_clusterIndex.size(); i++) {
			int index = pattern_clusterIndex.get(i);
			Float wt = c_wt.get(index);
			Float new_wt = (1 - n) * wt;
			c_wt.set(index, new_wt);
		}
		// System.out.println("AFTER c_wt: "+c_wt.toString());

		// 2. update edge weight by decrementing by factor of 1-n where n=0.5
		// System.out.println("BEFORE DBEdge_wt: "+DBEdge_wt.toString());
		ArrayList<Integer> edgeIndexUpdated = new ArrayList<Integer>();
		for (int i = 0; i < selectedPattern.size(); i++) {
			closureEdge e = selectedPattern.get(i);
			String e_str = e.getEdgeLabelString();
			int index = DBEdgeLabel.indexOf(e_str);
			if (edgeIndexUpdated.contains(index) == false)
				edgeIndexUpdated.add(index);
			float wt = DBEdge_wt.get(index);
			float new_wt = (1 - n) * wt;
			DBEdge_wt.set(index, new_wt);
		}
		// System.out.println("updated index: "+edgeIndexUpdated.toString());
		// System.out.println("AFTER DBEdge_wt: "+DBEdge_wt.toString());

	}

	private void PM_updateWeights2(ArrayList<closureEdge> selectedPattern, ArrayList<Integer> pattern_clusterIndex) {
		Float n = 0.5f;
		// System.out.println("------------------------------------------------");
		// System.out.println("pattern_clusterIndex:"+pattern_clusterIndex.toString());
		// for(int i=0; i<selectedPattern.size(); i++)
		// selectedPattern.get(i).print();
		// System.out.println("------------------------------------------------");
		// System.out.println("updating weights");
		// System.out.println("BEFORE c_wt: "+c_wt.toString());
		// System.out.println("pattern_clusterIndex: "+pattern_clusterIndex.toString());
		// 1. update cluster weight by decrementing by factor of 1-n where n=0.5
		for (int i = 0; i < pattern_clusterIndex.size(); i++) {
			int index = pattern_clusterIndex.get(i);
			Float wt = c_wt2.get(index);
			Float new_wt = (1 - n) * wt;
			c_wt2.set(index, new_wt);
		}
		// System.out.println("AFTER c_wt: "+c_wt.toString());

		// 2. update edge weight by decrementing by factor of 1-n where n=0.5
		// System.out.println("BEFORE DBEdge_wt: "+DBEdge_wt.toString());
		ArrayList<Integer> edgeIndexUpdated = new ArrayList<Integer>();
		for (int i = 0; i < selectedPattern.size(); i++) {
			closureEdge e = selectedPattern.get(i);
			String e_str = e.getEdgeLabelString();
			int index = DBEdgeLabel2.indexOf(e_str);
			if (edgeIndexUpdated.contains(index) == false)
				edgeIndexUpdated.add(index);
			float wt = DBEdge_wt2.get(index);
			float new_wt = (1 - n) * wt;
			DBEdge_wt2.set(index, new_wt);
		}
		// System.out.println("updated index: "+edgeIndexUpdated.toString());
		// System.out.println("AFTER DBEdge_wt: "+DBEdge_wt.toString());

	}

	private ArrayList<ArrayList<Integer>> PM_getCandidateClosureIndexForEachThread(int numThreads,
			ArrayList<Integer> indexList) {
		// System.out.println("indexList: ["+indexList.size()+"]
		// "+indexList.toString());
		ArrayList<ArrayList<Integer>> thread_indexList = new ArrayList<ArrayList<Integer>>();
		int numBucketsWithExtras = indexList.size() % numThreads;
		int defaultSize = (indexList.size() - numBucketsWithExtras) / numThreads;
		int size;
		int count = 0;
		for (int i = 0; i < numThreads; i++) {
			if (i < numBucketsWithExtras)
				size = defaultSize + 1;
			else
				size = defaultSize;
			ArrayList<Integer> thisThread_indexList = new ArrayList<Integer>();
			for (int j = 0; j < size; j++)
				thisThread_indexList.add(indexList.get(count + j));
			thread_indexList.add(thisThread_indexList);
			count = count + size;
		}
		// UNCOMMENT for debugging
		// System.out.println("count "+count);
		/*
		 * for(int i=0; i<thread_indexList.size(); i++) { ArrayList<Integer>
		 * iList=thread_indexList.get(i); System.out.println("Thread "+i+": "); for(int
		 * j=0; j<iList.size(); j++) System.out.print(iList.get(j)+" "); }
		 */
		return thread_indexList;
	}

	private void PM_findBestPatternOfClosure(ArrayList<Integer> candidateClosureIndex, int minPatternSize,
			int maxPatternSize, ArrayList<Integer> GUIPatternSize, ArrayList<Integer> GUIPatternSizeCounter,
			int maxPatternPerSize) {
		System.out.println("STEP 4: nominate best patterns for each candidate closure");
		Long startTime = System.currentTimeMillis();
		candidatePatterns = new ArrayList<ArrayList<closureEdge>>();
		candidatePatterns_closureIndex = new ArrayList<Integer>();
		int np = Runtime.getRuntime().availableProcessors();
		// int np=1;

		// System.out.println("PM_findBestPatternOfClosure numProcessors
		// available="+np);
		// Long startTime=System.currentTimeMillis();
		// divide load into np-threads
		ArrayList<Thread> pattern_threadList = new ArrayList<Thread>();
		GeneratePatternThreadCompleteListener threadListener = new GeneratePatternThreadCompleteListener(
				candidatePatterns, candidatePatterns_closureIndex);
		ArrayList<ArrayList<Integer>> thread_candidateClosureIndex = PM_getCandidateClosureIndexForEachThread(np,
				candidateClosureIndex);

		System.out.println("closureGraphList size: " + closureGraphList.size());
		for (int i = 0; i < np; i++) {
			GeneratePatternThread t = new GeneratePatternThread(closureGraphList, thread_candidateClosureIndex.get(i),
					DBEdgeLabel, DBEdge_wt, minPatternSize, maxPatternSize, i, threadListener, GUIPatternSize,
					GUIPatternSizeCounter, maxPatternPerSize, DBVertexLabel, DBVertexLabelValency);
			Thread pThread = new Thread(t, t.getName());
			pThread.start();
			pattern_threadList.add(pThread);
		}
		try {
			for (int i = 0; i < np; i++) {
				// System.out.println(pattern_threadList.get(i).getName()+" joins");
				pattern_threadList.get(i).join();
			}
		} catch (InterruptedException ex) {
			// Exceptions.printStackTrace(ex);
		}

		boolean SOME_THREAD_STILL_ALIVE = false;
		for (int i = 0; i < pattern_threadList.size(); i++) {
			if (pattern_threadList.get(i).isAlive()) {
				SOME_THREAD_STILL_ALIVE = true;
				i = pattern_threadList.size();
			}
		}
		while (SOME_THREAD_STILL_ALIVE) {
			try {
				Thread.sleep(10);
				for (int i = 0; i < pattern_threadList.size(); i++) {
					if (pattern_threadList.get(i).isAlive()) {
						SOME_THREAD_STILL_ALIVE = true;
						i = pattern_threadList.size();
					}
				}
			} catch (InterruptedException ex) {
				// Exceptions.printStackTrace(ex);
			}
		}
		System.out.println("all pattern threads are DEAD!!! can proceed");
		/*
		 * Object obj = new Object(); try { synchronized (obj) { while
		 * (pattern_threadList.size()>0) {//Or any Loops //Do Something
		 * //System.out.println("no. of active threads left: "+pattern_threadList.size()
		 * ); obj.wait(10);//Sample obj.wait(1000); 1 second sleep } } } catch
		 * (InterruptedException ex) { //SomeFishCatching }
		 */
		System.out.println("candidatePatterns: " + candidatePatterns.size());
		Long endTime = System.currentTimeMillis();
		System.out.println("nominate candidate pattern time: " + (endTime - startTime) + " ms");
		// Long stopTime=System.currentTimeMillis();
		// System.out.println("time taken:"+ (stopTime-startTime)+" ms");
		// System.out.println("candidatePatterns: "+candidatePatterns.size());
		// for(int i=0; i<=15; i++)
		// {
		// ArrayList<closureEdge> p=candidatePatterns.get(i);
		// System.out.println("pattern "+i);
		// for(int j=0; j<p.size(); j++)
		// p.get(j).print();
		// }

		candidatePatterns = threadListener.getCandidatePatterns();
		candidatePatterns_closureIndex = threadListener.getCandidatePatternClosureIndex();
	}

	private void PM_findBestPatternOfClosure2(ArrayList<Integer> candidateClosureIndex, int minPatternSize,
			int maxPatternSize, ArrayList<Integer> GUIPatternSize, ArrayList<Integer> GUIPatternSizeCounter,
			int maxPatternPerSize) {
		System.out.println("STEP 4: nominate best patterns for each candidate closure");
		Long startTime = System.currentTimeMillis();
		candidatePatterns2 = new ArrayList<ArrayList<closureEdge>>();
		candidatePatterns_closureIndex2 = new ArrayList<Integer>();
		int np = Runtime.getRuntime().availableProcessors();
		// int np=1;

		// System.out.println("PM_findBestPatternOfClosure numProcessors
		// available="+np);
		// Long startTime=System.currentTimeMillis();
		// divide load into np-threads
		ArrayList<Thread> pattern_threadList = new ArrayList<Thread>();
		GeneratePatternThreadCompleteListener threadListener = new GeneratePatternThreadCompleteListener(
				candidatePatterns2, candidatePatterns_closureIndex2);
		ArrayList<ArrayList<Integer>> thread_candidateClosureIndex = PM_getCandidateClosureIndexForEachThread(np,
				candidateClosureIndex);

		System.out.println("closureGraphList size: " + closureGraphList2.size());
		for (int i = 0; i < np; i++) {
			GeneratePatternThread t = new GeneratePatternThread(closureGraphList2, thread_candidateClosureIndex.get(i),
					DBEdgeLabel2, DBEdge_wt2, minPatternSize, maxPatternSize, i, threadListener, GUIPatternSize,
					GUIPatternSizeCounter, maxPatternPerSize, DBVertexLabel2, DBVertexLabelValency2);
			Thread pThread = new Thread(t, t.getName());
			pThread.start();
			pattern_threadList.add(pThread);
		}
		try {
			for (int i = 0; i < np; i++) {
				// System.out.println(pattern_threadList.get(i).getName()+" joins");
				pattern_threadList.get(i).join();
			}
		} catch (InterruptedException ex) {
			// Exceptions.printStackTrace(ex);
		}

		boolean SOME_THREAD_STILL_ALIVE = false;
		for (int i = 0; i < pattern_threadList.size(); i++) {
			if (pattern_threadList.get(i).isAlive()) {
				SOME_THREAD_STILL_ALIVE = true;
				i = pattern_threadList.size();
			}
		}
		while (SOME_THREAD_STILL_ALIVE) {
			try {
				Thread.sleep(10);
				for (int i = 0; i < pattern_threadList.size(); i++) {
					if (pattern_threadList.get(i).isAlive()) {
						SOME_THREAD_STILL_ALIVE = true;
						i = pattern_threadList.size();
					}
				}
			} catch (InterruptedException ex) {
				// Exceptions.printStackTrace(ex);
			}
		}
		System.out.println("all pattern threads are DEAD!!! can proceed");
		/*
		 * Object obj = new Object(); try { synchronized (obj) { while
		 * (pattern_threadList.size()>0) {//Or any Loops //Do Something
		 * //System.out.println("no. of active threads left: "+pattern_threadList.size()
		 * ); obj.wait(10);//Sample obj.wait(1000); 1 second sleep } } } catch
		 * (InterruptedException ex) { //SomeFishCatching }
		 */
		System.out.println("candidatePatterns: " + candidatePatterns2.size());
		Long endTime = System.currentTimeMillis();
		System.out.println("nominate candidate pattern time: " + (endTime - startTime) + " ms");
		// Long stopTime=System.currentTimeMillis();
		// System.out.println("time taken:"+ (stopTime-startTime)+" ms");
		// System.out.println("candidatePatterns: "+candidatePatterns.size());
		// for(int i=0; i<=15; i++)
		// {
		// ArrayList<closureEdge> p=candidatePatterns.get(i);
		// System.out.println("pattern "+i);
		// for(int j=0; j<p.size(); j++)
		// p.get(j).print();
		// }

		candidatePatterns2 = threadListener.getCandidatePatterns();
		candidatePatterns_closureIndex2 = threadListener.getCandidatePatternClosureIndex();
	}
	
	private void PM_findBestPatternOfClosure2_Updated(ArrayList<Integer> candidateClosureIndex, int minPatternSize,
			int maxPatternSize, ArrayList<Integer> GUIPatternSize, ArrayList<Integer> GUIPatternSizeCounter,
			int maxPatternPerSize) {
		System.out.println("STEP 4: nominate best patterns for each candidate closure");
		Long startTime = System.currentTimeMillis();
		candidatePatterns2 = new ArrayList<ArrayList<closureEdge>>();
		candidatePatterns_closureIndex2 = new ArrayList<Integer>();
		int np = Runtime.getRuntime().availableProcessors();
		// int np=1;

		// System.out.println("PM_findBestPatternOfClosure numProcessors
		// available="+np);
		// Long startTime=System.currentTimeMillis();
		// divide load into np-threads
		ArrayList<Thread> pattern_threadList = new ArrayList<Thread>();
		//GeneratePatternThreadCompleteListener threadListener = new GeneratePatternThreadCompleteListener(candidatePatterns2, candidatePatterns_closureIndex2);
		
		GeneratePatternThreadCompleteListenerUpdated  threadListener = new GeneratePatternThreadCompleteListenerUpdated(candidatePatterns2, candidatePatterns_closureIndex2);
		
		ArrayList<ArrayList<Integer>> thread_candidateClosureIndex = PM_getCandidateClosureIndexForEachThread(np,
				candidateClosureIndex);

		System.out.println("closureGraphList size: " + closureGraphList2.size());
		for (int i = 0; i < np; i++) {
			//GeneratePatternThread t = new GeneratePatternThread(closureGraphList2, thread_candidateClosureIndex.get(i),
			//		DBEdgeLabel2, DBEdge_wt2, minPatternSize, maxPatternSize, i, threadListener, GUIPatternSize,
			//		GUIPatternSizeCounter, maxPatternPerSize, DBVertexLabel2, DBVertexLabelValency2);
					
			GeneratePatternThreadUpdated t = new GeneratePatternThreadUpdated(closureGraphList2, thread_candidateClosureIndex.get(i),
				DBEdgeLabel2, DBEdge_wt2, minPatternSize, maxPatternSize, i, threadListener, GUIPatternSize,
				GUIPatternSizeCounter, maxPatternPerSize, DBVertexLabel2, DBVertexLabelValency2, this.trietree);
			Thread pThread = new Thread(t, t.getName());
			pThread.start();
			pattern_threadList.add(pThread);
		}
		try {
			for (int i = 0; i < np; i++) {
				// System.out.println(pattern_threadList.get(i).getName()+" joins");
				pattern_threadList.get(i).join();
			}
		} catch (InterruptedException ex) {
			// Exceptions.printStackTrace(ex);
		}

		boolean SOME_THREAD_STILL_ALIVE = false;
		for (int i = 0; i < pattern_threadList.size(); i++) {
			if (pattern_threadList.get(i).isAlive()) {
				SOME_THREAD_STILL_ALIVE = true;
				i = pattern_threadList.size();
			}
		}
		while (SOME_THREAD_STILL_ALIVE) {
			try {
				Thread.sleep(10);
				for (int i = 0; i < pattern_threadList.size(); i++) {
					if (pattern_threadList.get(i).isAlive()) {
						SOME_THREAD_STILL_ALIVE = true;
						i = pattern_threadList.size();
					}
				}
			} catch (InterruptedException ex) {
				// Exceptions.printStackTrace(ex);
			}
		}
		System.out.println("all pattern threads are DEAD!!! can proceed");
		/*
		 * Object obj = new Object(); try { synchronized (obj) { while
		 * (pattern_threadList.size()>0) {//Or any Loops //Do Something
		 * //System.out.println("no. of active threads left: "+pattern_threadList.size()
		 * ); obj.wait(10);//Sample obj.wait(1000); 1 second sleep } } } catch
		 * (InterruptedException ex) { //SomeFishCatching }
		 */
		System.out.println("candidatePatterns: " + candidatePatterns2.size());
		Long endTime = System.currentTimeMillis();
		System.out.println("nominate candidate pattern time: " + (endTime - startTime) + " ms");
		// Long stopTime=System.currentTimeMillis();
		// System.out.println("time taken:"+ (stopTime-startTime)+" ms");
		// System.out.println("candidatePatterns: "+candidatePatterns.size());
		// for(int i=0; i<=15; i++)
		// {
		// ArrayList<closureEdge> p=candidatePatterns.get(i);
		// System.out.println("pattern "+i);
		// for(int j=0; j<p.size(); j++)
		// p.get(j).print();
		// }

		candidatePatterns2 = threadListener.getCandidatePatterns();
		candidatePatterns_closureIndex2 = threadListener.getCandidatePatternClosureIndex();
	}

	private ArrayList<ArrayList<Integer>> readClusterFile(String fileName) {
		String strLine = null;
		File fin = new File(fileName);
		BufferedReader br;
		String delimiter = "\t";
		int counter = 0;
		ArrayList<ArrayList<Integer>> clusterGraphID = new ArrayList<ArrayList<Integer>>();
		try {
			br = new BufferedReader(new InputStreamReader(new BufferedInputStream(new FileInputStream(fin))));
			while ((strLine = br.readLine()) != null) {
				// there are some lines to be ignored...these contains ":"
				if (!strLine.contains(":")) {
					// each line is a cluster and the items in each line is the graph id (delimited
					// by space)
					counter++;
				//	System.out.println("Cluster " + counter + ": " + strLine);
					ArrayList<Integer> aCluster = new ArrayList<Integer>();
					int spaceIndex = strLine.indexOf(delimiter);
					while (spaceIndex != -1) {
						int graphId = Integer.parseInt(strLine.substring(0, spaceIndex));
						strLine = strLine.substring(spaceIndex + 1);
						spaceIndex = strLine.indexOf(delimiter);
						aCluster.add(graphId);
						if (fullyContainedGraphID.contains(graphId) == false)
							fullyContainedGraphID.add(graphId);
					}
					clusterGraphID.add(aCluster);
				}
			}
			br.close();
			// System.out.println("clusterGraphID.size="+clusterGraphID.size());
			// for(int i=0; i<clusterGraphID.size(); i++)
			// System.out.println(i+": "+clusterGraphID.get(i).toString());
		} catch (Exception ex) {
			System.out.println("Exception: ");
			ex.printStackTrace();
		}
		//System.out.println("All graph id list: " + fullyContainedGraphID.size());
		return clusterGraphID;
	}

	private ArrayList<ArrayList<Integer>> readClusterFile2(String fileName) {
		String strLine = null;
		File fin = new File(fileName);
		BufferedReader br;
		String delimiter = "\t";
		int counter = 0;
		ArrayList<ArrayList<Integer>> clusterGraphID = new ArrayList<ArrayList<Integer>>();
		try {
			br = new BufferedReader(new InputStreamReader(new BufferedInputStream(new FileInputStream(fin))));
			while ((strLine = br.readLine()) != null) {
				// there are some lines to be ignored...these contains ":"
				if (!strLine.contains(":")) {
					// each line is a cluster and the items in each line is the graph id (delimited
					// by space)
					counter++;
					System.out.println("Cluster " + counter + ": " + strLine);
					ArrayList<Integer> aCluster = new ArrayList<Integer>();
					int spaceIndex = strLine.indexOf(delimiter);
					while (spaceIndex != -1) {
						int graphId = Integer.parseInt(strLine.substring(0, spaceIndex));
						strLine = strLine.substring(spaceIndex + 1);
						spaceIndex = strLine.indexOf(delimiter);
						aCluster.add(graphId);
						if (fullyContainedGraphID2.contains(graphId) == false)
							fullyContainedGraphID2.add(graphId);
					}
					clusterGraphID.add(aCluster);
				}
			}
			br.close();
			// System.out.println("clusterGraphID.size="+clusterGraphID.size());
			// for(int i=0; i<clusterGraphID.size(); i++)
			// System.out.println(i+": "+clusterGraphID.get(i).toString());
		} catch (Exception ex) {
			System.out.println("Exception: ");
			ex.printStackTrace();
		}
		System.out.println("All graph id list: " + fullyContainedGraphID2.size());
		return clusterGraphID;
	}

	private int PM_generateClusterClosure2(String filename, ArrayList<ArrayList<Integer>> original_clusterIDList) {
		System.out.println("STEP 2: generating graph closure");
		Long startTime = System.currentTimeMillis();
		int np = Runtime.getRuntime().availableProcessors();
		System.out.println("PM_findBestPatternOfClosure numProcessors available=" + np);
		// Long startTime=System.currentTimeMillis();
		int totalGraphs = 0;
		for (int i = 0; i < original_clusterIDList.size(); i++) {
			// System.out.println("Cluster "+i+":
			// "+original_clusterIDList.get(i).toString());
			totalGraphs = totalGraphs + original_clusterIDList.get(i).size();
			// System.out.println("Number of totalGraphs:"+ Integer.toString(totalGraphs));
		}
		// divide load into np-threads
		ArrayList<String> dbEdgeLabels = new ArrayList<String>();
		ArrayList<Integer> dbEdgeLabelsFreq = new ArrayList<Integer>();
		ArrayList<String> dbVertexLabels = new ArrayList<String>();
		ArrayList<Integer> dbVertexLabelValency = new ArrayList<Integer>();
		GenerateClosureThreadCompleteListener threadListener = new GenerateClosureThreadCompleteListener();
		// get Graph ID For Each Thread
		ArrayList<ArrayList<ArrayList<Integer>>> thread_closureGraphIndex = getClosureGraphIDForEachThread(np,
				original_clusterIDList);
		// get Closure ID For Each Thread
		ArrayList<ArrayList<Integer>> thread_closureIndex = getClosureIndexForEachThread(np, original_clusterIDList);
		ArrayList<Thread> threadList = new ArrayList<Thread>();

		for (int i = 0; i < thread_closureIndex.size(); i++)
			System.out.println(i + ": " + thread_closureIndex.get(i).toString());
		for (int i = 0; i < np; i++) {
			GenerateClosureThread t = new GenerateClosureThread(filename, thread_closureGraphIndex.get(i),
					thread_closureIndex.get(i), i, threadListener);
			Thread gpThread = new Thread(t, t.getName());
			gpThread.start();
			threadList.add(gpThread);
			// if(true) return 0;
		}
		try {
			for (int i = 0; i < np; i++) {
				threadList.get(i).join();
				// System.out.println(threadList.get(i).getName()+" join");
			}
		} catch (InterruptedException ex) {
			// Exceptions.printStackTrace(ex);
		}
		boolean SOME_THREAD_STILL_ALIVE = false;
		for (int i = 0; i < threadList.size(); i++) {
			if (threadList.get(i).isAlive()) {
				SOME_THREAD_STILL_ALIVE = true;
				i = threadList.size();
			}
		}
		while (SOME_THREAD_STILL_ALIVE) {
			try {
				Thread.sleep(10);
				for (int i = 0; i < threadList.size(); i++) {
					if (threadList.get(i).isAlive()) {
						SOME_THREAD_STILL_ALIVE = true;
						i = threadList.size();
					}
				}
			} catch (InterruptedException ex) {
				// Exceptions.printStackTrace(ex);
			}
		}
		System.out.println("all Closure threads are DEAD!!! can proceed");
		dbEdgeLabels = threadListener.getDBEdgeLabel();
		dbEdgeLabelsFreq = threadListener.getDBEdgeLabelFreq();
		dbVertexLabels = threadListener.getDBVertexLabel();
		dbVertexLabelValency = threadListener.getDBVertexLabelValency();
		Comparator<DBStat> comparator = new DBStatComparator();
		PriorityQueue<DBStat> DBStatEdgeLabels;// the unique edge labels found in the graphs in the DB and the no. of
												// graphs having that edge label. Sorted in decreasing frequency
		DBStatEdgeLabels = new PriorityQueue<DBStat>(dbEdgeLabels.size(), comparator);
		for (int i = 0; i < dbEdgeLabels.size(); i++) {
			DBStat e_stat = new DBStat(dbEdgeLabels.get(i), dbEdgeLabelsFreq.get(i));
			DBStatEdgeLabels.add(e_stat);
		}
		for (int i = 0; i < dbEdgeLabels.size(); i++) {
			DBStat e_stat = DBStatEdgeLabels.poll();
			DBEdgeLabel2.add(e_stat.getLabel());
			DBEdgeLabelFreq2.add(e_stat.getFreq());
		}
		for (int i = 0; i < dbVertexLabels.size(); i++) {
			String vLabel = dbVertexLabels.get(i);
			int vLabel_index = DBVertexLabel2.indexOf(vLabel);
			if (vLabel_index == -1) {
				DBVertexLabel2.add(vLabel);
				DBVertexLabelValency2.add(dbVertexLabelValency.get(i));
			} else {
				if (DBVertexLabelValency2.get(vLabel_index) < dbVertexLabelValency.get(i))
					DBVertexLabelValency2.set(vLabel_index, dbVertexLabelValency.get(i));
			}
		}

		System.out.println("DBVertexLabel2: " + DBVertexLabel2.toString());
		System.out.println("DBVertexLabelValency2: " + DBVertexLabelValency2.toString());

		maxClosureSize2 = threadListener.getMaxClosureSize();
		closureGraphList2 = threadListener.getClosureGraph();
		closureGraphIndexList2 = threadListener.getClosureGraphIndex();

		Long endTime = System.currentTimeMillis();
		System.out.println("closure generation time: " + (endTime - startTime) + " ms");

		System.out.println("DBEdgeLabel2:" + DBEdgeLabel2.toString());
		System.out.println("DBEdgeLabelFreq2:" + DBEdgeLabelFreq2.toString());
		System.out.println("!!!!!!!!!! No. of distinct edge labels=" + DBEdgeLabel2.size());

		// return threadListener.getTotalGraphs();
		return totalGraphs;
	}

	private int PM_generateClusterClosure(String filename, ArrayList<ArrayList<Integer>> original_clusterIDList) {
		System.out.println("STEP 2: generating graph closure");
		Long startTime = System.currentTimeMillis();
		int np = Runtime.getRuntime().availableProcessors();
		System.out.println("PM_generateClusterClosure numProcessors available=" + np);
		// Long startTime=System.currentTimeMillis();
		int totalGraphs = 0;
		for (int i = 0; i < original_clusterIDList.size(); i++) {
			// System.out.println("Cluster "+i+":
			// "+original_clusterIDList.get(i).toString());
			totalGraphs = totalGraphs + original_clusterIDList.get(i).size();
			// System.out.println("Number of totalGraphs:"+ Integer.toString(totalGraphs));
		}
		// divide load into np-threads
		ArrayList<String> dbEdgeLabels = new ArrayList<String>();
		ArrayList<Integer> dbEdgeLabelsFreq = new ArrayList<Integer>();
		ArrayList<String> dbVertexLabels = new ArrayList<String>();
		ArrayList<Integer> dbVertexLabelValency = new ArrayList<Integer>();
		// Each time the GenerateClosureThread is completed, auto call threadComplete
		// method, and threadListener will collect all info of threads
		GenerateClosureThreadCompleteListener threadListener = new GenerateClosureThreadCompleteListener();
		// get Graph ID For Each Thread
		ArrayList<ArrayList<ArrayList<Integer>>> thread_closureGraphIndex = getClosureGraphIDForEachThread(np,
				original_clusterIDList);
		// get Closure ID For Each Thread
		ArrayList<ArrayList<Integer>> thread_closureIndex = getClosureIndexForEachThread(np, original_clusterIDList);
		ArrayList<Thread> threadList = new ArrayList<Thread>();

		for (int i = 0; i < thread_closureIndex.size(); i++)
			System.out.println(i + ": " + thread_closureIndex.get(i).toString());
		for (int i = 0; i < np; i++) {
			GenerateClosureThread t = new GenerateClosureThread(filename, thread_closureGraphIndex.get(i),
					thread_closureIndex.get(i), i, threadListener);
			Thread gpThread = new Thread(t, t.getName());
			gpThread.start();
			threadList.add(gpThread);
			// if(true) return 0;
		}
		try {
			for (int i = 0; i < np; i++) {
				threadList.get(i).join();
				// System.out.println(threadList.get(i).getName()+" join");
			}
		} catch (InterruptedException ex) {
			// Exceptions.printStackTrace(ex);
		}
		boolean SOME_THREAD_STILL_ALIVE = false;
		for (int i = 0; i < threadList.size(); i++) {
			if (threadList.get(i).isAlive()) {
				SOME_THREAD_STILL_ALIVE = true;
				i = threadList.size();
			}
		}
		while (SOME_THREAD_STILL_ALIVE) {
			try {
				Thread.sleep(10);
				for (int i = 0; i < threadList.size(); i++) {
					if (threadList.get(i).isAlive()) {
						SOME_THREAD_STILL_ALIVE = true;
						i = threadList.size();
					}
				}
			} catch (InterruptedException ex) {
				// Exceptions.printStackTrace(ex);
			}
		}
		System.out.println("all Closure threads are DEAD!!! can proceed");
		dbEdgeLabels = threadListener.getDBEdgeLabel();
		dbEdgeLabelsFreq = threadListener.getDBEdgeLabelFreq();
		dbVertexLabels = threadListener.getDBVertexLabel();
		dbVertexLabelValency = threadListener.getDBVertexLabelValency();
		Comparator<DBStat> comparator = new DBStatComparator();
		PriorityQueue<DBStat> DBStatEdgeLabels;// the unique edge labels found in the graphs in the DB and the no. of
												// graphs having that edge label. Sorted in decreasing frequency
		DBStatEdgeLabels = new PriorityQueue<DBStat>(dbEdgeLabels.size(), comparator);
		for (int i = 0; i < dbEdgeLabels.size(); i++) {
			DBStat e_stat = new DBStat(dbEdgeLabels.get(i), dbEdgeLabelsFreq.get(i));
			DBStatEdgeLabels.add(e_stat);
		}
		for (int i = 0; i < dbEdgeLabels.size(); i++) {
			DBStat e_stat = DBStatEdgeLabels.poll();
			DBEdgeLabel.add(e_stat.getLabel());
			DBEdgeLabelFreq.add(e_stat.getFreq());
		}
		for (int i = 0; i < dbVertexLabels.size(); i++) {
			String vLabel = dbVertexLabels.get(i);
			int vLabel_index = DBVertexLabel.indexOf(vLabel);
			if (vLabel_index == -1) {
				DBVertexLabel.add(vLabel);
				DBVertexLabelValency.add(dbVertexLabelValency.get(i));
			} else {
				if (DBVertexLabelValency.get(vLabel_index) < dbVertexLabelValency.get(i))
					DBVertexLabelValency.set(vLabel_index, dbVertexLabelValency.get(i));
			}
		}

		System.out.println("DBVertexLabel: " + DBVertexLabel.toString());
		System.out.println("DBVertexLabelValency: " + DBVertexLabelValency.toString());

		maxClosureSize = threadListener.getMaxClosureSize();
		closureGraphList = threadListener.getClosureGraph();
		closureGraphIndexList = threadListener.getClosureGraphIndex();

		Long endTime = System.currentTimeMillis();
		System.out.println("closure generation time: " + (endTime - startTime) + " ms");

		System.out.println("DBEdgeLabel:" + DBEdgeLabel.toString());
		System.out.println("DBEdgeLabelFreq:" + DBEdgeLabelFreq.toString());
		System.out.println("!!!!!!!!!! No. of distinct edge labels=" + DBEdgeLabel.size());

		// return threadListener.getTotalGraphs();
		return totalGraphs;
	}

	private ArrayList<ArrayList<ArrayList<Integer>>> getClosureGraphIDForEachThread(int numThreads,
			ArrayList<ArrayList<Integer>> indexList) {
		// System.out.println("indexList: ["+indexList.size()+"]
		// "+indexList.toString());
		ArrayList<ArrayList<ArrayList<Integer>>> thread_indexList = new ArrayList<ArrayList<ArrayList<Integer>>>();
		int numBucketsWithExtras = indexList.size() % numThreads;
		int defaultSize = (indexList.size() - numBucketsWithExtras) / numThreads;
		int size;
		int count = 0;
		for (int i = 0; i < numThreads; i++) {
			if (i < numBucketsWithExtras)
				size = defaultSize + 1;
			else
				size = defaultSize;
			ArrayList<ArrayList<Integer>> thisThread_indexList = new ArrayList<ArrayList<Integer>>();
			for (int j = 0; j < size; j++)
				thisThread_indexList.add(indexList.get(count + j));
			thread_indexList.add(thisThread_indexList);
			count = count + size;
		}
		// UNCOMMENT for debugging
		// System.out.println("count "+count);
		/*
		 * for(int i=0; i<thread_indexList.size(); i++) { ArrayList<Integer>
		 * iList=thread_indexList.get(i); System.out.println("Thread "+i+": "); for(int
		 * j=0; j<iList.size(); j++) System.out.print(iList.get(j)+" "); }
		 */
		return thread_indexList;
	}

	private ArrayList<ArrayList<Integer>> getClosureIndexForEachThread(int numThreads,
			ArrayList<ArrayList<Integer>> indexList) {
		// System.out.println("indexList: ["+indexList.size()+"]
		// "+indexList.toString());
		ArrayList<ArrayList<Integer>> thread_indexList = new ArrayList<ArrayList<Integer>>();
		int numBucketsWithExtras = indexList.size() % numThreads;
		int defaultSize = (indexList.size() - numBucketsWithExtras) / numThreads;
		int size;
		int count = 0;
		for (int i = 0; i < numThreads; i++) {
			if (i < numBucketsWithExtras)
				size = defaultSize + 1;
			else
				size = defaultSize;
			ArrayList<Integer> thisThread_indexList = new ArrayList<Integer>();
			for (int j = 0; j < size; j++)
				thisThread_indexList.add(count + j);
			thread_indexList.add(thisThread_indexList);
			count = count + size;
		}
		// UNCOMMENT for debugging
		// System.out.println("count "+count);
		/*
		 * for(int i=0; i<thread_indexList.size(); i++) { ArrayList<Integer>
		 * iList=thread_indexList.get(i); System.out.println("Thread "+i+": "); for(int
		 * j=0; j<iList.size(); j++) System.out.print(iList.get(j)+" "); }
		 */
		return thread_indexList;
	}

	public static String getFCT_Name() {
		return FCT_Name;
	}

	public static void setFCT_Name(String fCT_Name) {
		FCT_Name = fCT_Name;
	}



	public static String getFCT_Name_Updated() {
		return FCT_Name_Updated;
	}

	public static void setFCT_Name_Updated(String fCT_Name_Updated) {
		FCT_Name_Updated = fCT_Name_Updated;
	}

	public void setDataBaseName(String dataBaseName) {
		DataBaseName = dataBaseName;
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////////

	public String getDbName() {
		return dbName;
	}
	public int getGUISize() {
		return GUISize;
	}

	public void setDbName(String dbName) {
		this.dbName = dbName;
	}


	public void setInitialPatternName(String initialPatternName) {
		InitialPatternName = initialPatternName;
	}

	public void setInitialClusterName(String initialClusterName) {
		InitialClusterName = initialClusterName;
	}


	public static String getTG_Name() {
		return TG_Name;
	}

	public static void setTG_Name(String tG_Name) {
		TG_Name = tG_Name;
	}


	public static String getFEG_Name() {
		return FEG_Name;
	}

	public static void setFEG_Name(String fEG_Name) {
		FEG_Name = fEG_Name;
	}
	
	
	public static String getIFEG_Name() {
		return IFEG_Name;
	}

	public static void setIFEG_Name(String iFEG_Name) {
		IFEG_Name = iFEG_Name;
	}


	
	public static String getTP_Name() {
		return TP_Name;
	}

	public static void setTP_Name(String tP_Name) {
		TP_Name = tP_Name;
	}


	public static String getFEP_Name() {
		return FEP_Name;
	}

	public static void setFEP_Name(String fEP_Name) {
		FEP_Name = fEP_Name;
	}


	public static String getIFEP_Name() {
		return IFEP_Name;
	}

	public static void setIFEP_Name(String iFEP_Name) {
		IFEP_Name = iFEP_Name;
	}


	
	public static String getTG_Name_Updated() {
		return TG_Name_Updated;
	}

	public static void setTG_Name_Updated(String tG_Name_Updated) {
		TG_Name_Updated = tG_Name_Updated;
	}


	
	public static String getFEG_Name_Updated() {
		return FEG_Name_Updated;
	}

	public static void setFEG_Name_Updated(String fEG_Name_Updated) {
		FEG_Name_Updated = fEG_Name_Updated;
	}


	
	
	public static String getIFEG_Name_Updated() {
		return IFEG_Name_Updated;
	}

	public static void setIFEG_Name_Updated(String iFEG_Name_Updated) {
		IFEG_Name_Updated = iFEG_Name_Updated;
	}

	public static String getTP_Name_Updated() {
		return TP_Name_Updated;
	}

	public static void setTP_Name_Updated(String tP_Name_Updated) {
		TP_Name_Updated = tP_Name_Updated;
	}

	
	public static String getFEP_Name_Updated() {
		return FEP_Name_Updated;
	}

	public static void setFEP_Name_Updated(String fEP_Name_Updated) {
		FEP_Name_Updated = fEP_Name_Updated;
	}


	public static String getIFEP_Name_Updated() {
		return IFEP_Name_Updated;
	}

	public static void setIFEP_Name_Updated(String iFEP_Name_Updated) {
		IFEP_Name_Updated = iFEP_Name_Updated;
	}

	
	public float getKappa() {
		return Kappa;
	}

	public void setKappa(float kappa) {
		Kappa = kappa;
	}

	
	public float getLamda_sp() {
		return Lamda_sp;
	}

	public void setLamda_sp(float lamda_sp) {
		Lamda_sp = lamda_sp;
	}

	
	public float getLamda_div() {
		return Lamda_div;
	}

	public void setLamda_div(float lamda_div) {
		Lamda_div = lamda_div;
	}

	
	public float getLamda_cog() {
		return Lamda_cog;
	}

	public void setLamda_cog(float lamda_cog) {
		Lamda_cog = lamda_cog;
	}


	
	public float getLamda_lcov() {
		return Lamda_lcov;
	}

	public void setLamda_lcov(float lamda_lcov) {
		Lamda_lcov = lamda_lcov;
	}


	public int getSampledDataSizeForTesting() {
		return SampledDataSizeForTesting;
	}

	public void setSampledDataSizeForTesting(int sampledDataSizeForTesting) {
		SampledDataSizeForTesting = sampledDataSizeForTesting;
	}

	public String getUpdateClusterName() {
		return UpdateClusterName;
	}

	public void setUpdateClusterName(String updateClusterName) {
		UpdateClusterName = updateClusterName;
	}


	public String getDataBaseName() {
		return DataBaseName;
	}

	public ArrayList<Integer> getfullyContainedGraphID() {
		return fullyContainedGraphID;
	}

	public ArrayList<Integer> getfullyContainedGraphID2() {
		return fullyContainedGraphID2;
	}

	public String getInitialPatternName() {
		return InitialPatternName;
	}

	public String getInitialClusterName() {
		return InitialClusterName;
	}

}
